### 一、SpringMVC:

**Spring MVC的工作原理是怎样的**

**在将SpringMVC之前我们先来看一下什么是MVC模式**

MVC：MVC是一种设计模式

#### 1）MVC的原理图：

![](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/MVC.png)

M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）

V-View 视图（做界面的展示  jsp，html……）

C-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）

#### 2）SpringMVC框架结构

![img](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/SpringMVC.png)

背诵口诀：上映下适

**看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解）**

第一步:用户发起请求到前端控制器（DispatcherServlet）

第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找

第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain）

第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）

第五步：处理器适配器去执行Handler

第六步：Handler执行完给处理器适配器返回ModelAndView

第七步：处理器适配器向前端控制器返回ModelAndView

第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析

第九步：视图解析器像前端控制器返回View

第十步：前端控制器对视图进行渲染

第十一步：前端控制器向用户响应结果

**看到这些步骤我相信大家很感觉非常的乱，这是正常的，但是这里主要是要大家理解springMVC中的几个组件：**

前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。

处理器映射器（HandlerMapping）：根据URL去查找处理器

处理器（Handler）：（需要程序员去写代码处理逻辑的）

处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）

视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面



![img](https://images2017.cnblogs.com/blog/330611/201710/330611-20171023150730676-300068307.png)



### 二、Bean生命周期

4大步骤：实例化 -> 属性赋值 -> 初始化 -> 销毁

1.以ApplocationContext上下文单例模式装配bean为例，深入探讨bean的生命周期：

![img](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/SingleSpringBean.png)





2.以Spring Factory装配bean为例：

![img](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/FactorySpringBean.png)





#### 1）可以简述为以下九步

1.实例化bean对象(通过构造方法或者工厂方法)

2.设置对象属性(setter等)（依赖注入）

3.如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）

4.如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身

5.将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法

6.调用Bean的初始化方法

7.将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法

8.使用Bean		

9.容器关闭之前，调用Bean的销毁方法

#### **2）线性安全问题：**

对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。

对于原型(prototype)Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。

bean默认是单例的所以是线程不安全的

Bean 、controller、service和dao层本身都不是线程安全的

 因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的（prototype：多例）。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。 

详细点的文档：https://www.cnblogs.com/myseries/p/11729800.html



#### 3）spring中Bean的作用域

**1. singleton：**Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域。

**2. prototype：**每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。

**3. request：**在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。

**4. session：**在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。

**5. global Session：**在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。

## **三、SpringBoot的启动流程:**

**1.当我们启动SpringBoot的时候，先动用启动类中的静态run方法**

[![img](https://img2020.cnblogs.com/blog/2105697/202105/2105697-20210514003937330-1664256001.jpg)](https://img2020.cnblogs.com/blog/2105697/202105/2105697-20210514003937330-1664256001.jpg)

**2.run方法中最重要的两个环节**
a.创建 ApplicationContext容器
b.刷新 ApplicationContext容器

**3.在刷新容器的时候会去解析启动类，而启动类的注解使用的是@SpringBootApplication。**

这是一个复合注解，里面包含了@EnableAutoConfiguration，@Configuration，@ComponentScan这三个注解

* @EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置
* @Configuration：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境
* @ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下

**4.三个注解中，@EnableAutoConfiguration会开启自动配置，同时会去依赖的包中寻找spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包**。

**5.将jar包中的自动配置类加到容器中并进行实例化，完成自动装配。**

## 四、Spring

### 1.说说Spring 里用到了哪些设计模式?

`单例模式`：Spring 中的 Bean 默认情况下都是单例的。无需多说。

`工厂模式`：工厂模式主要是通过 BeanFactory 和 ApplicationContext 来生产 Bean 对象。

`代理模式`：最常见的 AOP 的实现方式就是通过代理来实现，Spring主要是使用 JDK 动态代理和 CGLIB 代理。

`模板方法模式`：主要是一些对数据库操作的类用到，比如 JdbcTemplate、JpaTemplate，因为查询数据库的建立连接、执行查询、关闭连接几个过程，非常适用于模板方法。

### 2.谈谈你对IOC 和 AOP 的理解？他们的实现原理是什么？

IOC 叫做控制反转，指的是通过Spring来管理对象的创建、配置和生命周期，这样相当于把控制权交给了Spring，不需要人工来管理对象之间复杂的依赖关系，这样做的好处就是解耦。在Spring里面，主要提供了 BeanFactory 和 ApplicationContext 两种 IOC 容器，通过他们来实现对 Bean 的管理。[Spring的IOC实现原理](https://www.jianshu.com/p/4b31dacf3a63)

AOP 叫做面向切面编程，他是一个编程范式，目的就是提高代码的模块性。Srping AOP 基于动态代理的方式实现，如果是实现了接口的话就会使用 JDK 动态代理，反之则使用 CGLIB 代理，Spring中 AOP 的应用主要体现在 事务、日志、异常处理等方面，通过在代码的前后做一些增强处理，可以实现对业务逻辑的隔离，提高代码的模块化能力，同时也是解耦。Spring主要提供了 Aspect 切面、JoinPoint 连接点、PointCut 切入点、Advice 增强等实现方式。

### 3. JDK 动态代理和 CGLIB 代理有什么区别？

JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。他基于反射的机制实现，生成一个实现同样接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。

而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。他的底层原理是基于 asm 第三方框架，通过修改字节码生成成成一个子类，然后重写父类的方法，实现对代码的增强。



* 1、CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高(1.6和1.7的时候，CGLib更快;1.8的时候，jdk更快)
* 2、CGLib在创建对象的时候所花费的时间却比JDK动态代理多
* 3、singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反之，则适合用JDK动态代理
* 4、JDK生成的代理类类型是Proxy(因为继承的是Proxy)，CGLIB生成的代理类类型是Enhancer类型
* 5、JDK动态代理是面向接口的，CGLib动态代理是通过字节码底层继承代理类来实现（如果被代理类被final关键字所修饰，那么会失败）
* 6、如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；如果要被代理的对象不是实现类，那么Spring会强制使用CGLib来实现动态代理。 



### 4. Spring AOP 和 AspectJ AOP 有什么区别？

Spring AOP 基于动态代理实现，属于运行时增强。

AspectJ 则属于编译时增强，主要有3种方式：

1. 编译时织入：指的是增强的代码和源代码我们都有，直接使用 AspectJ 编译器编译就行了，编译之后生成一个新的类，他也会作为一个正常的 Java 类装载到JVM。
2. 编译后织入：指的是代码已经被编译成 class 文件或者已经打成 jar 包，这时候要增强的话，就是编译后织入，比如你依赖了第三方的类库，又想对他增强的话，就可以通过这种方式。
3. 加载时织入：指的是在 JVM 加载类的时候进行织入。

总结下来的话，就是 Spring AOP 只能在运行时织入，不需要单独编译，性能相比 AspectJ 编译织入的方式慢，而 AspectJ 只支持编译前后和类加载时织入，性能更好，功能更加强大。

### 5. FactoryBean 和 BeanFactory有什么区别？

BeanFactory 是 Bean 的工厂， ApplicationContext 的父类，IOC 容器的核心，负责生产和管理 Bean 对象。

FactoryBean 是 Bean，可以通过实现 FactoryBean 接口定制实例化 Bean 的逻辑，通过代理一个Bean对象，对方法前后做一些操作。

### 7.Spring是怎么解决循环依赖的？



**先看一个循环依赖问题**

**现象**

循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：

![img](https:////upload-images.jianshu.io/upload_images/4634752-b466a2ce581a6403.png?imageMogr2/auto-orient/strip|imageView2/2/w/308/format/webp)

如何理解“依赖”呢，在Spring中有：

- 构造器循环依赖
- field属性注入循环依赖

直接上代码：

**构造器循环依赖**



```java
@Service
public class A {  
    public A(B b) {  }
}

@Service
public class B {  
    public B(C c) {  
    }
}

@Service
public class C {  
    public C(A a) {  }
}
```

结果：项目启动失败，发现了一个cycle

![img](https:////upload-images.jianshu.io/upload_images/4634752-df8aa5b9f98345fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

**2.field属性注入循环依赖**

```java
@Service
public class A1 {  
    @Autowired  
    private B1 b1;
}

@Service
public class B1 {  
    @Autowired  
    public C1 c1;
}

@Service
public class C1 {  
    @Autowired  public A1 a1;
}
```

结果：项目启动成功

![img](https:////upload-images.jianshu.io/upload_images/4634752-846426c9fb153f6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

**3.field属性注入循环依赖（prototype）**

```kotlin
@Service
@Scope("prototype")
public class A1 {  
    @Autowired  
    private B1 b1;
}

@Service
@Scope("prototype")
public class B1 {  
    @Autowired  
    public C1 c1;
}

@Service
@Scope("prototype")
public class C1 {  
    @Autowired  public A1 a1;
}
```

结果：项目启动失败，发现了一个cycle。

![img](https:////upload-images.jianshu.io/upload_images/4634752-4e4f92fdafab2005.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

**现象总结**：同样对于循环依赖的场景，构造器注入和prototype类型的属性注入都会初始化Bean失败。因为@Service默认是单例的，所以单例的属性注入是可以成功的。



​	

首先，Spring 解决循环依赖有两个前提条件：

1. 不全是构造器方式的循环依赖
2. 必须是单例

基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化的对象。

第一级缓存：用来保存实例化、初始化都完成的对象

第二级缓存：用来保存实例化完成，但是未初始化完成的对象

第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnmFsqZZ4gkrIRbV5o351H2AKQpf8yvnt5PXLsbCR8bLyMGRDEAslaMMl3AhGJq8bkMUNETTh5qpQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

假设一个简单的循环依赖场景，A、B互相依赖。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnmFsqZZ4gkrIRbV5o351H2MNTicM1Yr2ZicnqkgNZky17S90C9icBc9yHzIowluMykeHibvhNsOTkia0Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

A对象的创建过程：

1. 创建对象A，实例化的时候把A对象工厂放入三级缓存

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnmFsqZZ4gkrIRbV5o351H2ic0qR8shPvuk9mib9YEvBqtb4iasibz7Bk1pyZR2HbichnN4LVpK3Y1pMCA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

1. A注入属性时，发现依赖B，转而去实例化B
2. 同样创建对象B，注入属性时发现依赖A，一次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnmFsqZZ4gkrIRbV5o351H2AIXA8Ic8iaSIBst74uO1cib8wrbAfQpc3icONdicnK8yvialmlLJicUEuWXg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

1. 接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存
2. 最后，一级缓存中保存着实例化、初始化都完成的A、B对象

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnmFsqZZ4gkrIRbV5o351H24oPiaNGtpjbUhSxW4HNlPqMEFg10eaLU0V7gfrFmHJRv25pwic9XS7JQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。

### 8. 为什么要三级缓存？二级不行吗？

不可以，主要是为了生成代理对象。

因为三级缓存中放的是生成具体对象的匿名内部类，他可以生成代理对象，也可以是普通的实例对象。

使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。

假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，`BeanPostProcessor`去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUnmFsqZZ4gkrIRbV5o351H2tDZJooDFwPAn5JMKHpeLrLDtgkItbZtDpWf9cBVLXFWiaqSO2TYIrEQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 9.Spring事务传播机制有哪些？

1. **propagation_required**： 如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这也是通常我们的默认选择。
2. **propagation_requires_new**：创建新事务，无论当前存不存在事务，都创建新事务。
3. **propagation_nested：**如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。
4. **propagation_not_supported**：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
5. **propagation_never**：以非事务方式执行，如果当前存在事务，则抛出异常。
6. **propagation_mandatory**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
7. **propagation_supports**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘



### 10.Spring 事务在哪几种情况下会失效？为什么？

大概列举几种情况

1. 直接new出来的对象添加事务不起作用，因为只有spring定义的bean才接受事务。

2. 由于mysql的引擎用Myisam不支持事务，所以如果使用mysql的myisam引擎的话，事务不起作用。

3. 如果@Transaction注解到非public方法上，事务不起作用，这是因为spring的Aop特性。

4. 如果在当前类中进行内部调用方法，比如在A类中有a方法和b方法，a方法没有加@Transaction，b方法加了@Transaction，在方法a中调用方法b，方法b中的事务也不会生效。这是因为spring在扫描bean的时候会自动为标注了@Transaction注解类生成一个代理类，在有注解方法被调用时，实际上是代理类调用的，代理类在调用之前会开启事务，执行事务操作。但是同类中的方法相互调用，相当于this.b（），此时的b方法并非代理类调用，而是直接通过原有的bean直接调用，所以注解不起作用。

5. 异常类型错误，如果抛出的runtimeException事务才会回滚。

   因为默认回滚的是：RuntimeException，如果你想触发其他异常的回滚，需要在注解上配置一下，如：

   ```java
   @Transactional(rollbackFor = Exception.class)  
   ```

   这个配置仅限于 Throwable 异常类及其子类。

6. 如果异常被catch到，必须要抛出异常，事务才会回滚。

7. **@Transactional的扩展配置不支持事务**

`Propagation.NOT_SUPPORTED`：表示不以事务运行，当前若存在事务则挂起。这表示不支持以事务的方式运行，所以即使事务生效也是白搭！

```java
@Service  
public class OrderServiceImpl implements OrderService {  
   
    @Transactional  
    public void update(Order order) {  
        updateOrder(order);  
    }  
   
    @Transactional(propagation = Propagation.NOT_SUPPORTED)  
    public void updateOrder(Order order) {  
        // update order  
    }  
   
}  
```



### 11.**SpringBoot的启动流程:**

**1.当我们启动SpringBoot的时候，先动用启动类中的静态run方法**

[![img](https://img2020.cnblogs.com/blog/2105697/202105/2105697-20210514003937330-1664256001.jpg)](https://img2020.cnblogs.com/blog/2105697/202105/2105697-20210514003937330-1664256001.jpg)

**2.run方法中最重要的两个环节**
a.创建 ApplicationContext容器
b.刷新 ApplicationContext容器

**3.在刷新容器的时候会去解析启动类，而启动类的注解使用的是@SpringBootApplication。**

这是一个复合注解，里面包含了@ComponentScan，@EnableAutoConfiguration，@SpringBootConfiguration 这三个注解

* @EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置
* @Configuration：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境
* @ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下

**4.三个注解中，@EnableAutoConfiguration会开启自动配置，同时会去依赖的包中寻找spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包**。

**5.将jar包中的自动配置类加到容器中并进行实例化，完成自动装配。**



### 12.**SpringBoot-starter的作用**


SpringBoot拥有很多方便使用的starter（Spring提供的starter命名规范spring-boot-starter-xxx.jar，第三方提供的starter命名规范xxx-spring-boot-starter.jar），比如spring-boot-starter-log4j、mybatis-spring-boot-starter.jar等，各自都代表了一个相对完整的功能模块。

SpringBoot-starter是一个集成接合器，完成两件事：

* 引入模块所需的相关jar包
* 自动配置各自模块所需的属性

**Spring Boot 还提供了其它的哪些 Starter Project Options**

Spring Boot 也提供了其它的启动器项目包括，包括用于开发特定类型应用程序的典型依赖项。

spring-boot-starter-web-services - SOAP Web Services

spring-boot-starter-web - Web 和 RESTful 应用程序

spring-boot-starter-test - 单元测试和集成测试

spring-boot-starter-jdbc - 传统的 JDBC

spring-boot-starter-hateoas - 为服务添加 HATEOAS 功能

spring-boot-starter-security - 使用 SpringSecurity 进行身份验证和授权

spring-boot-starter-data-jpa - 带有 Hibeernate 的 Spring Data JPA

spring-boot-starter-data-rest - 使用 Spring Data REST 公布简单的 REST 服务



### 13.[Spring SpringMVC SpringBoot 常用注解说明](https://blog.csdn.net/a964921988/article/details/88933707)

**@Component @Bean 区别:**

1、@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。

2、@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。

两者的目的是一样的，都是注册bean到Spring容器中。

区别：

@Component（@Controller、@Service、@Repository）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。而@Bean注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。

@Component 作用于类，@Bean作用于方法。

总结：

@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。

### 14.[Spring中事务的使用、抽象机制及模拟Spring事务实现](https://blog.51cto.com/u_15050718/2624255)

### 15.[SpringBoot自定义注解的简单实现](https://www.jianshu.com/p/e1073a12c571)

## 五、Spring 和 SpringBoot 的区别 ?

****

##### Spring ：

Spring 这个框架相信大家都不陌生，Spring框架为开发Java应用程序提供了全面的架构支持。
它包以下这些功能，如 **依赖注入**，**开箱即用**的模块 。
栗如：

1），Spring JDBC === **对JDBC的简单封装**
2），Spring MVC === **Spring MVC框架的实现**
3），Spring Security === **安全管理框架**
4），Spring AOP === **面向切面编程**
5），Spring ORM === **对象关系映射，集成orm框架（Mybatis，Hibernate）**
6），Spring Test === **Spring测试，提供junit 和 mock测试功能**

这些模块缩短了开发时间，提高了开发效率。（这应该是每个框架都有特点吧？）在Java Web开发的早期阶段，我们需要编写大量的代码来将记录插入到数据库中。但是通过使用Spring JDBC模块的JDBCTemplate，我们可以将操作简化为几行代码。

附：
我感觉Spring最大的目标是实现一个全方位的整合方案，整合持久层框架(Mybatis，Hibernate)，整合Web框架的整合（Struts）。起一个粘合剂的效果。

##### SpringBoot ：

Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。

##### SpringBoot 中的一些特征(特点)：

1. 创建独立的Spring应用程序
2. 内嵌Servlet容器，无需部署war 文件包。
3. 提供starter(用maven封装的一个模块)简化maven配置
4. 自动配置Spring(其实就是自动装配一些我们可能会用到的对象实例，这可以说是优点，也可以说是缺点)
5. 提供生成就绪功能,如指标，健康检查和外部配置
6. 无代码生成和xml配置

##### spring、springmvc、springboot的区别是什么？

 spring和springMvc：

1. spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；
2. springMvc是spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于spring框架中WEB层开发的一部分；

springMvc和springBoot：

1、springMvc属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；

2、springBoot框架相对于springMvc框架来说，更专注于开发微服务后台接口，不开发前端视图，同时遵循默认优于配置，简化了插件配置流程，不需要配置xml，相对springmvc，大大简化了配置流程；

总结：

1、Spring 框架就像一个家族，有众多衍生产品例如 boot、security、jpa等等。但他们的基础都是Spring的ioc、aop等. ioc 提供了依赖注入的容器， aop解决了面向横切面编程，然后在此两者的基础上实现了其他延伸产品的高级功能；

2、springMvc主要解决WEB开发的问题，是基于Servlet 的一个MVC框架，通过XML配置，统一开发前端视图和后端逻辑；

3、由于Spring的配置非常复杂，各种XML、JavaConfig、servlet处理起来比较繁琐，为了简化开发者的使用，从而创造性地推出了springBoot框架，默认优于配置，简化了springMvc的配置流程；但区别于springMvc的是，springBoot专注于单体微服务接口开发，和前端解耦，虽然springBoot也可以做成springMvc前后台一起开发，但是这就有点不符合springBoot框架的初衷了；



## 六、工作中常用到哪些设计模式



![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwnEoGbnjibl4txzyz5QMz2YbK74BrHJNZuF7Rj7peaDmKibiaiaaJ616ju3SPl4AS7hiboJdmJDcw59Hg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 使用设计模式的好处



重用性高、扩展性性能、灵活性单元测试、结构型设计模式：松耦合、避免了客户端环境与产品对象复杂的构造逻辑耦合



### 1.策略模式

#### 1.1 业务场景

假设有这样的业务场景，大数据系统把文件推送过来，根据不同类型采取**不同的解析**方式。多数的小伙伴就会写出以下的代码：

```
if(type=="A"){
   //按照A格式解析
 
}else if(type=="B"){
    //按B格式解析
}else{
    //按照默认格式解析
}
```

这个代码可能会存在哪些**问题呢**？

- 如果分支变多，这里的代码就会变得**臃肿，难以维护，可读性低**。
- 如果你需要接入一种新的解析类型，那只能在**原有代码上修改**。

说得专业一点的话，就是以上代码，违背了面向对象编程的**开闭原则**以及**单一原则**。

- **开闭原则**（对于扩展是开放的，但是对于修改是封闭的）：增加或者删除某个逻辑，都需要修改到原来代码
- **单一原则**（规定一个类应该只有一个发生变化的原因）：修改任何类型的分支逻辑代码，都需要改动当前类的代码。

如果你的代码就是酱紫：有多个`if...else`等条件分支，并且每个条件分支，可以封装起来替换的，我们就可以使用**策略模式**来优化。

#### 1.2 策略模式定义

**策略模式**定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的的客户。这个策略模式的定义是不是有点抽象呢？那我们来看点通俗易懂的比喻：

> 假设你跟不同性格类型的小姐姐约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去逛街买买买最合适。当然，目的都是为了得到小姐姐的芳心，请看电影、吃小吃、逛街就是不同的策略。

策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。

#### 1.3 策略模式使用

策略模式怎么使用呢？酱紫实现的：

- 一个接口或者抽象类，里面两个方法（一个方法匹配类型，一个可替换的逻辑实现方法）
- 不同策略的差异化实现(就是说，不同策略的实现类)
- 使用策略模式

##### 1.3.1 一个接口，两个方法

```
public interface IFileStrategy {
    
    //属于哪种文件解析类型
    FileTypeResolveEnum gainFileType();
    
    //封装的公用算法（具体的解析方法）
    void resolve(Object objectparam);
}
```

##### 1.3.2 不同策略的差异化实现

A 类型策略具体实现

```
@Component
public class AFileResolve implements IFileStrategy {
    
    @Override
    public FileTypeResolveEnum gainFileType() {
        return FileTypeResolveEnum.File_A_RESOLVE;
    }

    @Override
    public void resolve(Object objectparam) {
      logger.info("A 类型解析文件，参数：{}",objectparam);
      //A类型解析具体逻辑
    }
}
```

B 类型策略具体实现

```
@Component
public class BFileResolve implements IFileStrategy {
   
    @Override
    public FileTypeResolveEnum gainFileType() {
        return FileTypeResolveEnum.File_B_RESOLVE;
    }


    @Override
    public void resolve(Object objectparam) {
      logger.info("B 类型解析文件，参数：{}",objectparam);
      //B类型解析具体逻辑
    }
}
```

默认类型策略具体实现

```
@Component
public class DefaultFileResolve implements IFileStrategy {

    @Override
    public FileTypeResolveEnum gainFileType() {
        return FileTypeResolveEnum.File_DEFAULT_RESOLVE;
    }

    @Override
    public void resolve(Object objectparam) {
      logger.info("默认类型解析文件，参数：{}",objectparam);
      //默认类型解析具体逻辑
    }
}
```

##### 1.3.3 使用策略模式

如何使用呢？我们借助`spring`的生命周期，使用`ApplicationContextAware`接口，把对用的策略，初始化到`map`里面。然后对外提供`resolveFile`方法即可。

```
/**
 *  @author 公众号：捡田螺的小男孩
 */
@Component
public class StrategyUseService implements ApplicationContextAware{

  
    private Map<FileTypeResolveEnum, IFileStrategy> iFileStrategyMap = new ConcurrentHashMap<>();

    public void resolveFile(FileTypeResolveEnum fileTypeResolveEnum, Object objectParam) {
        IFileStrategy iFileStrategy = iFileStrategyMap.get(fileTypeResolveEnum);
        if (iFileStrategy != null) {
            iFileStrategy.resolve(objectParam);
        }
    }

    //把不同策略放到map
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map<String, IFileStrategy> tmepMap = applicationContext.getBeansOfType(IFileStrategy.class);
        tmepMap.values().forEach(strategyService -> iFileStrategyMap.put(strategyService.gainFileType(), strategyService));
    }
}
```

### 2. 责任链模式

#### 2.1 业务场景

我们来看一个常见的业务场景，下订单。下订单接口，基本的逻辑，一般有参数非空校验、安全校验、黑名单校验、规则拦截等等。很多伙伴会使用异常来实现：

```
public class Order {

    public void checkNullParam(Object param){
      //参数非空校验
      throw new RuntimeException();
    }
    public void checkSecurity(){
      //安全校验
      throw new RuntimeException();
    }
    public void checkBackList(){
        //黑名单校验
        throw new RuntimeException();
    }
    public void checkRule(){
        //规则拦截
        throw new RuntimeException();
    }

    public static void main(String[] args) {
        Order order= new Order();
        try{
            order.checkNullParam();
            order.checkSecurity ();
            order.checkBackList();
            order2.checkRule();
            System.out.println("order success");
        }catch (RuntimeException e){
            System.out.println("order fail");
        }
    }
}
```

这段代码使用了**异常**来做逻辑条件判断，如果后续逻辑越来越复杂的话，会出现一些问题：如异常只能返回异常信息，不能返回更多的字段，这时候需要**自定义异常类**。

并且，阿里开发手册规定：**禁止用异常做逻辑判断**。

> 【强制】 异常不要用来做流程控制，条件控制。说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。

如何优化这段代码呢？可以考虑**责任链模式**

#### 2.2 责任链模式定义

当你想要让一个**以上的对象**有机会能够处理某个请求的时候，就使用**责任链模式**。

> 责任链模式为请求创建了一个接收者对象的链。执行链上有多个对象节点，每个对象节点都有机会（条件匹配）处理请求事务，如果某个对象节点处理完了，就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。

责任链模式实际上是一种处理请求的模式，它让多个处理器（对象节点）都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwnEoGbnjibl4txzyz5QMz2YWuWz9sSm7ibd2DdCSeakUrMcRibOUseqBy89mzIxCBTuMpLsltB0x7GA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)责任链模式

打个比喻：

> 假设你晚上去上选修课，为了可以走点走，坐到了最后一排。来到教室，发现前面坐了好几个漂亮的小姐姐，于是你找张纸条，写上：“你好, 可以做我的女朋友吗？如果不愿意请向前传”。纸条就一个接一个的传上去了，后来传到第一排的那个妹子手上，她把纸条交给老师，听说老师40多岁未婚...

#### 2.3 责任链模式使用

责任链模式怎么使用呢？

- 一个接口或者抽象类
- 每个对象差异化处理
- 对象链（数组）初始化（连起来）

##### 2.3.1 一个接口或者抽象类

这个接口或者抽象类，需要：

- 有一个指向责任下一个对象的属性
- 一个设置下一个对象的set方法
- 给子类对象差异化实现的方法（如以下代码的doFilter方法）

```
/**
 *  关注公众号：捡田螺的小男孩
 */
public abstract class AbstractHandler {

    //责任链中的下一个对象
    private AbstractHandler nextHandler;

    /**
     * 责任链的下一个对象
     */
    public void setNextHandler(AbstractHandler nextHandler){
        this.nextHandler = nextHandler;
    }

    /**
     * 具体参数拦截逻辑,给子类去实现
     */
    public void filter(Request request, Response response) {
        doFilter(request, response);
        if (getNextHandler() != null) {
            getNextHandler().filter(request, response);
        }
    }

    public AbstractHandler getNextHandler() {
        return nextHandler;
    }

     abstract void doFilter(Request filterRequest, Response response);

}
```

##### 2.3.2 每个对象差异化处理

责任链上，每个对象的**差异化**处理，如本小节的业务场景，就有参数校验对象、安全校验对象、黑名单校验对象、规则拦截对象

```
/**
 * 参数校验对象
 **/
@Component
@Order(1) //顺序排第1，最先校验
public class CheckParamFilterObject extends AbstractHandler {

    @Override
    public void doFilter(Request request, Response response) {
        System.out.println("非空参数检查");
    }
}

/**
 *  安全校验对象
 */
@Component
@Order(2) //校验顺序排第2
public class CheckSecurityFilterObject extends AbstractHandler {

    @Override
    public void doFilter(Request request, Response response) {
        //invoke Security check
        System.out.println("安全调用校验");
    }
}
/**
 *  黑名单校验对象
 */
@Component
@Order(3) //校验顺序排第3
public class CheckBlackFilterObject extends AbstractHandler {

    @Override
    public void doFilter(Request request, Response response) {
        //invoke black list check
        System.out.println("校验黑名单");
    }
}

/**
 *  规则拦截对象
 */
@Component
@Order(4) //校验顺序排第4
public class CheckRuleFilterObject extends AbstractHandler {

    @Override
    public void doFilter(Request request, Response response) {
        //check rule
        System.out.println("check rule");
    }
}
```

##### 2.3.3 对象链连起来（初始化）&& 使用

```
@Component("ChainPatternDemo")
public class ChainPatternDemo {

    //自动注入各个责任链的对象
    @Autowired
    private List<AbstractHandler> abstractHandleList;

    private AbstractHandler abstractHandler;

    //spring注入后自动执行，责任链的对象连接起来
    @PostConstruct
    public void initializeChainFilter(){

        for(int i = 0;i<abstractHandleList.size();i++){
            if(i == 0){
                abstractHandler = abstractHandleList.get(0);
            }else{
                AbstractHandler currentHander = abstractHandleList.get(i - 1);
                AbstractHandler nextHander = abstractHandleList.get(i);
                currentHander.setNextHandler(nextHander);
            }
        }
    }

    //直接调用这个方法使用
    public Response exec(Request request, Response response) {
        abstractHandler.filter(request, response);
        return response;
    }

    public AbstractHandler getAbstractHandler() {
        return abstractHandler;
    }

    public void setAbstractHandler(AbstractHandler abstractHandler) {
        this.abstractHandler = abstractHandler;
    }
}
```

运行结果如下：

```
非空参数检查
安全调用校验
校验黑名单
check rule
```

### 3. 模板方法模式

#### 3.1 业务场景

假设我们有这么一个业务场景：内部系统不同商户，调用我们系统接口，去跟外部第三方系统交互（http方式）。走类似这么一个流程，如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpwnEoGbnjibl4txzyz5QMz2YCHJ3EVPk0phV52CfFLaLWKtvppyab32ra0wUN2icCZ9HpGEkPYLbhqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

一个请求都会经历这几个流程：

- 查询商户信息
- 对请求报文加签
- 发送http请求出去
- 对返回的报文验签

这里，有的商户可能是走代理出去的，有的是走直连。假设当前有A，B商户接入，不少伙伴可能这么实现，伪代码如下：

```
// 商户A处理句柄
CompanyAHandler implements RequestHandler {
   Resp hander(req){
   //查询商户信息
   queryMerchantInfo();
   //加签
   signature();
   //http请求（A商户假设走的是代理）
   httpRequestbyProxy()
   //验签
   verify();
   }
}
// 商户B处理句柄
CompanyBHandler implements RequestHandler {
   Resp hander(Rreq){
   //查询商户信息
   queryMerchantInfo();
   //加签
   signature();
   // http请求（B商户不走代理，直连）
   httpRequestbyDirect();
   // 验签
   verify(); 
   }
}
```

假设新加一个C商户接入，你需要再实现一套这样的代码。显然，这样代码就**重复**了，**一些通用的方法，却在每一个子类都重新写了这一方法**。

如何优化呢？可以使用**模板方法模式**。

#### 3.2 模板方法模式定义

定义一个操作中的算法的骨架流程，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。它的核心思想就是：定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现，这样不同的子类就可以定义出不同的步骤。

打个通俗的比喻：

> 模式举例：追女朋友要先“牵手”，再“拥抱”，再“接吻”， 再“拍拍..额..手”。至于具体你用左手还是右手牵，无所谓，但是整个过程，定了一个流程模板，按照模板来就行。

#### 3.3 模板方法使用

- 一个抽象类，定义骨架流程（抽象方法放一起）
- 确定的共同方法步骤，放到抽象类（去除抽象方法标记）
- 不确定的步骤，给子类去差异化实现

我们继续那以上的举例的业务流程例子，来一起用 模板方法优化一下哈：

##### 3.3.1 一个抽象类，定义骨架流程

因为一个个请求经过的流程为一下步骤：

- 查询商户信息
- 对请求报文加签
- 发送http请求出去
- 对返回的报文验签

所以我们就可以定义一个抽象类，包含请求流程的几个方法，方法首先都定义为抽象方法哈：

```
/**
 * 抽象类定义骨架流程（查询商户信息，加签，http请求，验签）
 */
abstract class AbstractMerchantService  { 

      //查询商户信息
      abstract queryMerchantInfo();
      //加签
      abstract signature();
      //http 请求
      abstract httpRequest();
       // 验签
       abstract verifySinature();
 
}
```

##### 3.3.2 确定的共同方法步骤，放到抽象类

```
abstract class AbstractMerchantService  { 

     //模板方法流程
     Resp handlerTempPlate(req){
           //查询商户信息
           queryMerchantInfo();
           //加签
           signature();
           //http 请求
           httpRequest();
           // 验签
           verifySinature();
     }
      // Http是否走代理（提供给子类实现）
      abstract boolean isRequestByProxy();
}
```

##### 3.3.3 不确定的步骤，给子类去差异化实现

因为是否走代理流程是**不确定**的，所以给子类去实现。

商户A的请求实现：

```
CompanyAServiceImpl extends AbstractMerchantService{
    Resp hander(req){
      return handlerTempPlate(req);
    }
    //走http代理的
    boolean isRequestByProxy(){
       return true;
    }
```

商户B的请求实现：

```
CompanyBServiceImpl extends AbstractMerchantService{
    Resp hander(req){
      return handlerTempPlate(req);
    }
    //公司B是不走代理的
    boolean isRequestByProxy(){
       return false;
    }
```

### 4. 观察者模式

#### 4.1 业务场景

登陆注册应该是最常见的业务场景了。就拿**注册**来说事，我们经常会遇到类似的场景，就是用户注册成功后，我们给用户发一条消息，又或者发个邮件等等，因此经常有如下的代码：

```
void register(User user){
  insertRegisterUser（user）;
  sendIMMessage();
  sendEmail()；
}
```

这块代码会有什么问题呢？如果产品又加需求：现在注册成功的用户，再给用户发一条短信通知。于是你又得改register方法的代码了。。。这是不是违反了**开闭原则**啦。

```
void register(User user){
  insertRegisterUser（user）;
  sendIMMessage();
  sendMobileMessage（）;
  sendEmail()；
}
```

并且，如果调**发短信的接口失败**了，是不是又影响到用户注册了？！这时候，是不是得加个异步方法给**通知消息**才好。。。

实际上，我们可以使用观察者模式优化。

#### 4.2 观察者模式定义

> 观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被完成业务的更新。

观察者模式属于行为模式，一个对象（被观察者）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。它的主要成员就是**观察者和被观察者**。

- 被观察者（Observerable）：目标对象，状态发生变化时，将通知所有的观察者。
- 观察者（observer）：接受被观察者的状态变化通知，执行预先定义的业务。

**使用场景：** 完成某件事情后，异步通知场景。如，登陆成功，发个IM消息等等。

#### 4.3 观察者模式使用

观察者模式实现的话，还是比较简单的。

- 一个被观察者的类Observerable ;
- 多个观察者Observer ；
- 观察者的差异化实现
- 经典观察者模式封装：EventBus实战

##### 4.3.1 一个被观察者的类Observerable 和 多个观察者Observer

```
public class Observerable {
   
   private List<Observer> observers 
      = new ArrayList<Observer>();
   private int state;
 
   public int getState() {
      return state;
   }
 
   public void setState(int state) {
      notifyAllObservers();
   }
 
   //添加观察者
   public void addServer(Observer observer){
      observers.add(observer);      
   }
   
   //移除观察者
   public void removeServer(Observer observer){
      observers.remove(observer);      
   }
   //通知
   public void notifyAllObservers(int state){
      if(state!=1){
          System.out.println(“不是通知的状态”);
         return ;
      }
   
      for (Observer observer : observers) {
         observer.doEvent();
      }
   }  
}
```

##### 4.3.2 观察者的差异化实现

```
 //观察者
 interface Observer {  
    void doEvent();  
}  
//Im消息
IMMessageObserver implements Observer{
    void doEvent（）{
       System.out.println("发送IM消息");
    }
}

//手机短信
MobileNoObserver implements Observer{
    void doEvent（）{
       System.out.println("发送短信消息");
    }
}
//EmailNo
EmailObserver implements Observer{
    void doEvent（）{
       System.out.println("发送email消息");
    }
}
```

##### 4.3.3 EventBus实战

自己搞一套观察者模式的代码，还是有点小麻烦。实际上，`Guava EventBus`就封装好了，它 提供一套基于注解的事件总线，api可以灵活的使用，爽歪歪。

我们来看下`EventBus`的实战代码哈，首先可以声明一个EventBusCenter类，它类似于以上被观察者那种角色`Observerable`。

```
public class EventBusCenter {

    private static EventBus eventBus = new EventBus();

    private EventBusCenter() {
    }

    public static EventBus getInstance() {
        return eventBus;
    }
     //添加观察者
    public static void register(Object obj) {
        eventBus.register(obj);
    }
    //移除观察者
    public static void unregister(Object obj) {
        eventBus.unregister(obj);
    }
    //把消息推给观察者
    public static void post(Object obj) {
        eventBus.post(obj);
    }
}
```

然后再声明观察者`EventListener`

```
public class EventListener {

    @Subscribe //加了订阅，这里标记这个方法是事件处理方法  
    public void handle(NotifyEvent notifyEvent) {
        System.out.println("发送IM消息" + notifyEvent.getImNo());
        System.out.println("发送短信消息" + notifyEvent.getMobileNo());
        System.out.println("发送Email消息" + notifyEvent.getEmailNo());
    }
}

//通知事件类
public class NotifyEvent  {

    private String mobileNo;

    private String emailNo;

    private String imNo;

    public NotifyEvent(String mobileNo, String emailNo, String imNo) {
        this.mobileNo = mobileNo;
        this.emailNo = emailNo;
        this.imNo = imNo;
    }
 }
```

使用demo测试：

```
public class EventBusDemoTest {

    public static void main(String[] args) {

        EventListener eventListener = new EventListener();
        EventBusCenter.register(eventListener);
        EventBusCenter.post(new NotifyEvent("13372817283", "123@qq.com", "666"));
        }
}
```

运行结果：

```
发送IM消息666
发送短信消息13372817283
发送Email消息123@qq.com
```

### 5. 工厂模式

#### 5.1 业务场景

工厂模式一般配合策略模式一起使用。用来去优化大量的`if...else...`或`switch...case...`条件语句。

我们就取第一小节中策略模式那个例子吧。根据不同的文件解析类型，创建不同的解析对象

```
 IFileStrategy getFileStrategy(FileTypeResolveEnum fileType){
     IFileStrategy  fileStrategy ;
     if(fileType=FileTypeResolveEnum.File_A_RESOLVE){
       fileStrategy = new AFileResolve();
     }else if(fileType=FileTypeResolveEnum.File_A_RESOLV){
       fileStrategy = new BFileResolve();
     }else{
       fileStrategy = new DefaultFileResolve();
     }
     return fileStrategy;
 }
```

其实这就是**工厂模式**，定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

策略模式的例子，没有使用上一段代码，而是借助spring的特性，搞了一个工厂模式，哈哈，小伙伴们可以回去那个例子细品一下，我把代码再搬下来，小伙伴们再品一下吧：

```
/**
 *  @author 公众号：捡田螺的小男孩
 */
@Component
public class StrategyUseService implements ApplicationContextAware{

    private Map<FileTypeResolveEnum, IFileStrategy> iFileStrategyMap = new ConcurrentHashMap<>();

    //把所有的文件类型解析的对象，放到map，需要使用时，信手拈来即可。这就是工厂模式的一种体现啦
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map<String, IFileStrategy> tmepMap = applicationContext.getBeansOfType(IFileStrategy.class);
        tmepMap.values().forEach(strategyService -> iFileStrategyMap.put(strategyService.gainFileType(), strategyService));
    }
}
```

#### 5.2 使用工厂模式

定义工厂模式也是比较简单的:

- 一个工厂接口，提供一个创建不同对象的方法。
- 其子类实现工厂接口，构造不同对象
- 使用工厂模式

##### 5.3.1 一个工厂接口

```
interface IFileResolveFactory{
   void resolve();
}
```

##### 5.3.2 不同子类实现工厂接口

```
class AFileResolve implements IFileResolveFactory{
   void resolve(){
      System.out.println("文件A类型解析");
   }
}

class BFileResolve implements IFileResolveFactory{
   void resolve(){
      System.out.println("文件B类型解析");
   }
}

class DefaultFileResolve implements IFileResolveFactory{
   void resolve(){
      System.out.println("默认文件类型解析");
   }
}
```

##### 5.3.3 使用工厂模式

```
//构造不同的工厂对象
IFileResolveFactory fileResolveFactory;
if(fileType=“A”){
    fileResolveFactory = new AFileResolve();
}else if(fileType=“B”){
    fileResolveFactory = new BFileResolve();
 }else{
    fileResolveFactory = new DefaultFileResolve();
}

fileResolveFactory.resolve();
```

一般情况下，对于工厂模式，你不会看到以上的代码。工厂模式会跟配合其他设计模式如策略模式一起出现的。

### 6. 单例模式

#### 6.1 业务场景

单例模式，**保证一个类仅有一个实例**，并提供一个访问它的全局访问点。I/O与数据库的连接,一般就用单例模式实现de的。Windows里面的Task Manager（任务管理器）也是很典型的单例模式。

来看一个单例模式的例子

```
/**
 *  公众号：捡田螺的小男孩
 */
public class LanHanSingleton {

    private static LanHanSingleton instance;

    private LanHanSingleton(){

    }

    public static LanHanSingleton getInstance(){
        if (instance == null) {
            instance = new LanHanSingleton();
        }
        return instance;
    }

}
 
```

以上的例子，就是**懒汉式**的单例实现。实例在需要用到的时候，才去创建，就比较懒。如果有则返回，没有则新建，需要加下 `synchronized`关键字，要不然可能存在**线性安全问题**。

#### 6.2 单例模式的经典写法

其实单例模式还有有好几种实现方式，如饿汉模式，双重校验锁，静态内部类，枚举等实现方式。

##### 6.2.1 饿汉模式

```
public class EHanSingleton {

   private static EHanSingleton instance = new EHanSingleton();
   
   private EHanSingleton(){      
   }

   public static EHanSingleton getInstance() {
       return instance;
   }
   
}
```

饿汉模式，它**比较饥饿、比较勤奋**，实例在初始化的时候就已经建好了，不管你后面有没有用到，都先新建好实例再说。这个就没有线程安全的问题，但是呢，浪费内存空间呀。

##### 6.2.2 双重校验锁

```
public class DoubleCheckSingleton {

   private static DoubleCheckSingleton instance;

   private DoubleCheckSingleton() { }
   
   public static DoubleCheckSingleton getInstance(){
       if (instance == null) {
           synchronized (DoubleCheckSingleton.class) {
               if (instance == null) {
                   instance = new DoubleCheckSingleton();
               }
           }
       }
       return instance;
   }
}
```

双重校验锁实现的单例模式，综合了懒汉式和饿汉式两者的优缺点。以上代码例子中，在synchronized关键字内外都加了一层  `if`条件判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间。

##### 6.2.3 静态内部类

```
public class InnerClassSingleton {

   private static class InnerClassSingletonHolder{
       private static final InnerClassSingleton INSTANCE = new InnerClassSingleton();
   }

   private InnerClassSingleton(){}
   
   public static final InnerClassSingleton getInstance(){
       return InnerClassSingletonHolder.INSTANCE;
   }
}
```

静态内部类的实现方式，效果有点类似双重校验锁。但这种方式只适用于静态域场景，双重校验锁方式可在实例域需要延迟初始化时使用。

##### 6.2.4 枚举

```
public enum SingletonEnum {

    INSTANCE;
    public SingletonEnum getInstance(){
        return INSTANCE;
    }
}
```

枚举实现的单例，代码简洁清晰。并且它还自动支持序列化机制，绝对防止多次实例化。



## 七、Mybatis

**1、什么是mybatis？**

（1）mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。

（2）mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。

（3）MyBatis 支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO映射成数据库中的记录。

 

**2、Mybait的优点：**

（1）简单易学，容易上手（相比于Hibernate） —- 基于SQL编程；

（2）JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；

（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDBC提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。

（4）提供了很多第三方插件（分页插件 / 逆向工程）；

（5）能够与Spring很好的集成；

（6）MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，解除sql与程序代码的耦合，便于统一管理和优化，并可重用。

（7）提供XML标签，支持编写动态SQL语句。

（8） 提供映射标签，支持对象与数据库的ORM字段关系映射。

（9）提供对象关系映射标签，支持对象关系组建维护。

 

**3、MyBatis框架的缺点：**

（1）SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。

（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

 

**4、MyBatis框架适用场合：**

（1）MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。

（2）对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。

 

**5、MyBatis与Hibernate有哪些不同？**

（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 

（2）Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 

（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 

 

**6、#{}和${}的区别是什么？**

\#{}是预编译处理，${}是字符串替换。

Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；

Mybatis在处理${}时，就是把${}替换成变量的值。

使用#{}可以有效的防止SQL注入，提高系统安全性。

 

**7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？**

第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。

   select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};

第2种： 通过来映射字段名和实体类属性名的一一对应的关系

select * from orders where order_id=#{id}

```xml
    <!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–>
    <result property = “orderno” column =”order_no”/>
    <result property=”price” column=”order_price” />
</reslutMap>
```

**8、 模糊查询like语句该怎么写?**

第1种：在Java代码中添加sql通配符。

```xml
string wildcardname = “%smi%”;
list<name> names = mapper.selectlike(wildcardname);

<select id=”selectlike”>
 select * from foo where bar like #{value}
</select>
```

第2种：在sql语句中拼接通配符，会引起sql注入

```xml
string wildcardname = “smi”;
list<name> names = mapper.selectlike(wildcardname);

<select id=”selectlike”>
     select * from foo where bar like "%"#{value}"%"
</select>
```

第3种：使用sql中的字符串拼接函数

```xml
<select id="searchStudents" resultType="com.example.entity.StudentEntity"
        parameterType="com.example.entity.StudentEntity">
        SELECT * FROM test_student
        <where>
            <if test="age != null and age != '' and compare != null and compare != ''">
                age
                ${compare}
                #{age}
            </if>
            <if test="name != null and name != ''">
                AND name LIKE CONCAT(CONCAT('%',#{name},'%'))
            </if>
            <if test="address != null and address != ''">
                AND address LIKE CONCAT(CONCAT('%',#{address},'%'))
            </if>
        </where>
        ORDER BY id
    </select>
```

**9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？**

Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。

**10、Mybatis是如何进行分页的？分页插件的原理是什么？**
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。

 **11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？**
第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

 

**12、如何执行批量插入?**

第1种：在java代码中反复调用

首先,创建一个简单的insert语句:

```xml
  <insert id=”insertname”>
       insert into names (name) values (#{value})
  </insert>
```

  然后在java代码中像下面这样执行批处理插入:

```java
list<string> names = new arraylist();
  names.add(“fred”);
  names.add(“barney”);
  names.add(“betty”);
  names.add(“wilma”);

  // 注意这里 executortype.batch
  sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);
  try {
   namemapper mapper = sqlsession.getmapper(namemapper.class);
   for (string name : names) {
       mapper.insertname(name);
   }
   sqlsession.commit();
  }catch(Exception e){
   e.printStackTrace();
   sqlSession.rollback(); 
   throw e; 
    }
    finally {
       sqlsession.close();
  }
```

第2种：使用foreach进行批量插入

```xml
 <!-- 批量导入设备（从Excel表中导入设备列表） -->
   <insert id="batchAddDevice">
   	INSERT INTO hk_device ( mac_address,device_type_id,descript, device_group_id,
   	receive_num,is_delete,device_status,create_time,create_user,update_time ) VALUES
<!--//index表示在迭代过程中，每次迭代到的位置，-->
   	 <foreach collection="devices" item="device" index="index" separator=",">
          ( #{device.macAddress},#{device.deviceTypeId},#{device.descript},
   		 #{device.deviceGroupId},#{device.receiveNum},#{device.isDelete},#{device.devStatus},
   		 #{device.createTime},#{device.createUser},#{device.updateTime} ) 
       </foreach>
   </insert>
   <!-- foreach标签，进行遍历 -->
    <!-- collection：遍历的集合，这里是QueryVo的ids属性 -->
   	<!-- item：遍历的项目，可以随便写，，但是和后面的#{}里面要一致 -->
   	<!-- open：在前面添加的sql片段 -->
   	<!-- close：在结尾处添加的sql片段 -->
   	<!-- separator：指定遍历的元素之间使用的分隔符 -->
```



**13、如何获取自动生成的(主)键值?**

insert 方法总是返回一个int值 - 这个值代表的是插入的行数。

而自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。

useGeneratedKeys true，需要你表主键自动增长 keyProperty id，主键名称为id 

示例:

```xml
<insert id="insertname" usegeneratedkeys="true" keyproperty="id">
     insert into names (name) values (#{name})
</insert>
```



```java
name name = new name();
name.setname(“fred”);
int rows = mapper.insertname(name);
// 完成后,id已经被设置到对象中
system.out.println(“rows inserted = ” + rows);
system.out.println(“generated key value = ” + name.getid());
```

**14、在mapper中如何传递多个参数?**

（1）第一种：

```xml
 //DAO层的函数 Public UserselectUser(String name,String area);
//对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。
<select id="selectUser"resultMap="BaseResultMap">  
    select *  fromuser_user_t   whereuser_name = #{0} anduser_area=#{1}  
</select>  
```

（2）第2种： 使用 @param 注解:

```java
  import org.apache.ibatis.annotations.param;
      public interface usermapper {
       user selectuser(@param(“username”) string username,
       @param(“hashedpassword”) string hashedpassword);
      }
```

然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):

```xml
  <select id=”selectuser” resulttype=”user”>
       select id, username, hashedpassword
       from some_table
       where username = #{username}
       and hashedpassword = #{hashedpassword}
</select>
```

（3）第三种：多个参数封装成map

```java
try{try{
//映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL
//由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数
Map<String, Object> map = new HashMap();
map.put(“start”, start);
map.put(“end”, end);
return sqlSession.selectList(“StudentID.pagination”, map);
}catch(Exception e){
e.printStackTrace();
sqlSession.rollback();
throw e; }
finally{
MybatisUtil.closeSqlSession();
}
```

**15、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？**

Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。

Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。

其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。

**16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？**

答：还有很多其他的标签，、、、、，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。

 **17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？**

 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。

 原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。

 

**18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？**

Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。

 

**19、 一对一、一对多的关联查询 ？**

```xml
<mapper namespace="com.lcb.mapping.userMapper">  
    <!--association  一对一关联查询 -->  
    <select id="getClass" parameterType="int" resultMap="ClassesResultMap">  
        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#{id}  
    </select>  

    <resultMap type="com.lcb.user.Classes" id="ClassesResultMap">  
        <!-- 实体类的字段名和数据表的字段名映射 -->  
        <id property="id" column="c_id"/>  
        <result property="name" column="c_name"/>  
        <association property="teacher" javaType="com.lcb.user.Teacher">  
            <id property="id" column="t_id"/>  
            <result property="name" column="t_name"/>  
        </association>  
    </resultMap>  

 

    <!--collection  一对多关联查询 -->  
    <select id="getClass2" parameterType="int" resultMap="ClassesResultMap2">  
        select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#{id}  
    </select>  
     
    <resultMap type="com.lcb.user.Classes" id="ClassesResultMap2">  
        <id property="id" column="c_id"/>  
        <result property="name" column="c_name"/>  
        <association property="teacher" javaType="com.lcb.user.Teacher">  
            <id property="id" column="t_id"/>  
            <result property="name" column="t_name"/>  
        </association>  
     
        <collection property="student" ofType="com.lcb.user.Student">  
            <id property="id" column="s_id"/>  
            <result property="name" column="s_name"/>  
        </collection>  
    </resultMap>  
</mapper> 
```

**20、MyBatis实现一对一有几种方式?具体怎么操作的？**

​    有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成; 嵌套查询是先查一个表,根据这个表里面 的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。

**21、MyBatis实现一对多有几种方式,怎么操作的？**

​    有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配 置collection节点配置一对多的类就可以完成; 嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。

**22、简述Mybatis的插件运行原理，以及如何编写一个插件。**

答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

编写插件：实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

 

**23、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？**

答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。

当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。

 

 **24、Mybatis的一级、二级缓存:**

1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。

2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；

3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

**25、什么是MyBatis的接口绑定,有什么好处？**

​    接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.

 **26、接口绑定有几种实现方式,分别是怎么实现的? **

​    接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.

 

**27、什么情况下用注解绑定,什么情况下用xml绑定 ？**

当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。

**28、使用MyBatis的mapper接口调用时有哪些要求？**

① Mapper接口方法名和mapper.xml中定义的每个sql的id相同 
② Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 
③ Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 
④ Mapper.xml文件中的namespace即是mapper接口的类路径。

 

**29、Mapper编写有哪几种方式？**

第一种：接口实现类继承SqlSessionDaoSupport： 
使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件 
（1）在sqlMapConfig.xml中配置mapper.xml的位置

```
<mappers>
    <mapper resource="mapper.xml文件的地址" />
    <mapper resource="mapper.xml文件的地址" />
</mappers>
```

（2）定义mapper接口
（3）实现类集成SqlSessionDaoSupport
mapper方法中可以this.getSqlSession()进行数据增删改查。
（4）spring 配置

```
<bean id=" " class="mapper接口的实现">
    <property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
</bean>
```

第二种：使用org.mybatis.spring.mapper.MapperFactoryBean：
（1）在sqlMapConfig.xml中配置mapper.xml的位置
如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置

```
<mappers>
    <mapper resource="mapper.xml文件的地址" />
    <mapper resource="mapper.xml文件的地址" />
</mappers>
```

（2）定义mapper接口
注意
①mapper.xml中的namespace为mapper接口的地址
②mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致
③Spring中定义

```
<bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
    <property name="mapperInterface"   value="mapper接口地址" /> 
    <property name="sqlSessionFactory" ref="sqlSessionFactory" /> 
</bean>

```

第三种：使用mapper扫描器：
（1）mapper.xml文件编写：
注意：
mapper.xml中的namespace为mapper接口的地址
mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致
如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置
（2）定义mapper接口
注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录
（3）配置mapper扫描器

```xml
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="mapper接口包地址"></property>
    <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/> 
</bean>
```

（4）使用扫描器后从spring容器中获取mapper的实现对象

**30、Mybatis比IBatis比较大的几个改进是什么？**

（1）有接口绑定,包括注解绑定sql和xml绑定Sql ,

（2）动态sql由原来的节点配置变成OGNL表达式,

（3）在一对一,一对多的时候引进了association,在一对多的时候引入了collection 节点,不过都是在resultMap里面配置。

 

**31、IBatis和MyBatis在核心处理类分别叫什么？**

IBatis里面的核心处理类交SqlMapClient, MyBatis里面的核心处理类叫做SqlSession

 

**32、IBatis和MyBatis在细节上的不同有哪些？**

（1）在sql里面变量命名有原来的#变量# 变成了#{变量} 原来的$变量$变成了${变量},；

（2）原来在sql节点里面的class都换名字交type；

（3）原来的queryForObject、queryForList 变成了selectOne、selectList；

（4）原来的别名设置在映射文件里面放在了核心配置文件



#### Mybatis Plus

Mybatis-Plus是一个Mybatis的增强工具，只是在Mybatis的基础上做了增强却不做改变，MyBatis-Plus支持所有Mybatis原生的特性，所以引入Mybatis-Plus不会对现有的Mybatis构架产生任何影响。



![图片](https://img-blog.csdnimg.cn/20190530134824262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTA4NTMw,size_16,color_FFFFFF,t_70)



![图片](https://img-blog.csdnimg.cn/2019053013474765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTA4NTMw,size_16,color_FFFFFF,t_70)

#### Mybatis 和 Mybatis Plus 的区别

**MyBatis:**

* 所有SQL语句全部自己写
* 手动解析实体关系映射转换为MyBatis内部对象注入容器
* 不支持Lambda形式调用

**Mybatis Plus:**

* 强大的条件构造器,满足各类使用需求
* 内置的Mapper,通用的Service,少量配置即可实现单表大部分CRUD操作
* 支持Lambda形式调用
* 提供了基本的CRUD功能,连SQL语句都不需要编写
  自动解析实体关系映射转换为MyBatis内部对象注入容器


#### MyBatis的优缺点

**优点**

* MyBatis封装了JBDC底层访问数据库的细节,使我们程序猿不需要与JDBC API打交道,就可以访问数据库

* MyBatis简单易学,程序猿直接编写SQL语句,适合于对SQL语句性能要求比较高的项目

* SQL语句封装在配置文件中，便于统一管理与维护，降低了程序的耦合度

* SQL代码从程序代码中彻底分离出来，可重用
  提供了动态SQL标签，支持编写动态SQL

* 提供映射标签，支持对象与数据库的ORM字段关系映射

  

**缺点**

* 过于依赖数据库SQL语句,导致数据库移植性差,更换数据库,如果SQL语句有差异,SQL语句工作量大
* 由于xml里标签id必须唯一，导致DAO中方法不支持方法重载

#### MyBatis-Plus 优点

* 依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring 。

* 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 。

* 预防Sql注入：内置 Sql 注入剥离器，有效预防Sql注入攻击 。

* 通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 。

* 5、多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题 。

* 支持热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动

* 支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作

* 支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码（生成自定义文件，避免开发重复代码），支持模板引擎、有超多自定义配置等。

* 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）。

* 支持关键词自动转义：支持数据库关键词（order、key…）自动转义，还可自定义关键词 。

* 内置分页插件：基于 Mybatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通List查询。

* 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询 。

* 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作。

* 默认将实体类的类名查找数据库中的表，使用@TableName(value=“table1”)注解指定表名，@TableId指定表主键，若字段与表中字段名保持一致可不加注解。

   







