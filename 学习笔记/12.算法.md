# 	一、LeetCode算法

## 算法1.双指针

### [1.LeetCode167. 两数之和 II - 输入有序数组[中等]](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

> 给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。
>
> 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
>
> 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
>
> 你所设计的解决方案必须只使用常量级的额外空间。
>
>
> 示例 1：
>
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。



使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
- 如果 sum > target，移动较大的元素，使 sum 变小一些；
- 如果 sum < target，移动较小的元素，使 sum 变大一些。

数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为 O(1)。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/437cb54c-5970-4ba9-b2ef-2541f7d6c81e.gif)



```java
public int[] twoSum(int[] numbers, int target) {
    if (numbers == null) return null;
    int i = 0, j = numbers.length - 1;
    while (i < j) {
        int sum = numbers[i] + numbers[j];
        if (sum == target) {
            return new int[]{i + 1, j + 1};
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
    return null;
}
```



### [2.LeetCode633. 平方数之和[中等]](https://leetcode-cn.com/problems/sum-of-square-numbers/)

> 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。
>
>  
>
> 示例 1：
>
> 输入：c = 5
> 输出：true
> 解释：1 * 1 + 2 * 2 = 5

不失一般性，可以假设 a*≤*b*。初始时a*=0，b*=*&radic;c，进行如下操作：

* 如果 a^2 + b^2 = c，我们找到了题目要求的一个解，返回true；
* 如果 a^2 + b^2 < c，此时需要将 a的值加 1，继续查找；
* 如果 a^2 + b^2 > c，此时需要将 b 的值减 1，继续查找。

当 a=b 时，结束查找，此时如果仍然没有找到整数 a 和 b满足 a^2 + b^2 = c，则说明不存在题目要求的解，返回 false。



```java
class Solution {
    public boolean judgeSquareSum(int c) {
        long left = 0;
        long right = (long) Math.sqrt(c);
        while (left <= right) {
            long sum = left * left + right * right;
            if (sum == c) {
                return true;
            } else if (sum > c) {
                right--;
            } else {
                left++;
            }
        }
        return false;
    }
}
```



### [3.LeetCode345. 反转字符串中的元音字母[简单]](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

> 给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。
>
> 元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。
>
>  
>
> 示例 1：
>
> 输入：s = "hello"
> 输出："holle"

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a7cb8423-895d-4975-8ef8-662a0029c772.png)



使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。

为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。

- 时间复杂度为 O(N)：只需要遍历所有元素一次
- 空间复杂度 O(1)：只需要使用两个额外变量

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ef25ff7c-0f63-420d-8b30-eafbeea35d11.gif)



```java
private final static HashSet<Character> vowels = new HashSet<>(
        Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));

public String reverseVowels(String s) {			···
    if (s == null) return null;
    int i = 0, j = s.length() - 1;
    char[] result = new char[s.length()];
    while (i <= j) {
        char ci = s.charAt(i);
        char cj = s.charAt(j);
        if (!vowels.contains(ci)) {
            result[i++] = ci;
        } else if (!vowels.contains(cj)) {
            result[j--] = cj;
        } else {
            result[i++] = cj;
            result[j--] = ci;
        }
    }
    return new String(result);
}
```



### [4.Leetcode680. 验证回文字符串 Ⅱ[简单]](https://leetcode-cn.com/problems/valid-palindrome-ii/)

> 给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。
>
> **示例 1:**
>
> ```
> 输入: s = "aba"
> 输出: true
> ```

使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fcc941ec-134b-4dcd-bc86-1702fd305300.gif)



本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。

在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。

在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5f30a7-8bfa-4ecc-ab5d-747c77818964.gif)



```java
public boolean validPalindrome(String s) {
    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
        }
    }
    return true;
}

private boolean isPalindrome(String s, int i, int j) {
    while (i < j) {
        if (s.charAt(i++) != s.charAt(j--)) {
        return false;
    }
    return true;
}
```



### [5.LeetCode88合并两个有序数组[简单]](https://leetcode-cn.com/problems/merge-sorted-array/)

> 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。	
>
> 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
>
> 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
>
>  
>
> 示例 1：
>
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> 解释：需要合并 [1,2,3] 和 [2,5,6] 。
> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

思路：将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。如下面的动画所示：

![gif](http://assets.leetcode-cn.com/solution-static/88/1.gif)

我们为两个数组分别设置一个指针p1与p2来作为队列的头部指针。代码实现如下：



```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = 0, p2 = 0;
        int[] sorted = new int[m + n];
        int cur;
        while (p1 < m || p2 < n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] < nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
}
```

### [6. Leetcode141.判断链表是否存在环[简单]](https://leetcode-cn.com/problems/linked-list-cycle/description/)

> 给你一个链表的头节点 head ，判断链表中是否有环。
>
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
>
> 如果链表中存在环 ，则返回 true 。 否则，返回 false 。
>
> 示例 1：
>
> [![img](https://img-blog.csdnimg.cn/20210601100806384.png)
>
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20201102143802622.gif&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647874664&t=4dbf227af9afeb4bc468eed50d338266)

使用双指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```



### [7.LeetCode524. 通过删除字母匹配到字典里最长单词[中等]](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

> 给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。
>
> 如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。
>
>  
>
> 示例 1：
>
> 输入：s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]
> 输出："apple"



思路和算法

根据题意，我们需要解决两个问题：

* 如何判断dictionary 中的字符串 tt 是否可以通过删除 ss 中的某些字符得到；
* 如何找到长度最长且字典序最小的字符串。

第 1个问题实际上就是判断 tt 是否是 ss 的子序列。因此只要能找到任意一种t 在 s中出现的方式，即可认为 t 是 s的子序列。而当我们从前往后匹配时，可以发现每次贪心地匹配最靠前的字符是最优决策。

> 假定当前需要匹配字符 c，而字符 c 在 s 中的位置 x1和 x2出现（x1 < x2），那么贪心取x1 是最优解，因为x2后面能取到的字符，x1也都能取到，并且通过x1与x2之间的可选字符，更有希望能匹配成功。

这样，我们初始化两个指针 i和 j，分别指向 t和 s的初始位置。每次贪心地匹配，匹配成功则 i和 j同时右移，匹配 t的下一个位置，匹配失败则 j右移，i不变，尝试用 s的下一个字符匹配 tt。

最终如果 i 移动到 t的末尾，则说明 t 是 s的子序列。

第 2个问题可以通过遍历dictionary 中的字符串，并维护当前长度最长且字典序最小的字符串来找到。



```java
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String res = "";
        for (String t : dictionary) {
            int i = 0, j = 0;
            while (i < t.length() && j < s.length()) {
                if (t.charAt(i) == s.charAt(j)) {
                    ++i;
                }
                ++j;
            }
            if (i == t.length()) {
                if (t.length() > res.length() || (t.length() == res.length() && t.compareTo(res) < 0)) {
                    res = t;
                }
            }
        }
        return res;
    }
}
```



### [8.LeetCode881. 救生艇[中等]](https://leetcode-cn.com/problems/boats-to-save-people/)

> 给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。
>
> 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。
>
> 返回 承载所有人所需的最小船数 。
>
>  
>
> 示例 1：
>
> 输入：people = [1,2], limit = 3
> 输出：1
> 解释：1 艘船载 (1, 2)

解题思路
观察这么一件事儿，越重的人，越容易自己独占一条船。如果想尽可能地利用空间，就尽可能往它们上面塞人。

如果最重的，重到连最轻的都加不上去，那它只能自己一个人一条船。剩下的问题就是一个递归的解了;
如果最重的可以带上最轻的，那它们俩一艘船是最优的。因为最轻的能和任一个人一起，但其他人不一定能和最重的人一起。

排序后，双指针。如果两人的和小于等于limit，那么左右凑一对儿，往中间递归；否则右边独自占一条船。



```cpp
class Solution {
    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);
        int n = people.length, ans = 0;
        for(int left=0,right=n-1;left<=right;ans++)
            if(people[left] + people[right--] <= limit)
                left++;
        return ans;
    }
}
```



## 算法2.二分查找法

![image.png](https://pic.leetcode-cn.com/1628933645-lfjMLm-image.png)

**正常实现**

```text
Input : [1,2,3,4,5]
key : 3
return the index : 2
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] > key) {
            h = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```

**时间复杂度**

二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。

**m 计算**

有两种计算中值 m 的方式：

- m = (l + h) / 2
- m = l + (h - l) / 2

l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。

**未成功查找的返回值**

循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：

- -1：以一个错误码表示没有查找到 key
- l：将 key 插入到 nums 中的正确位置

**变种**

二分查找可以有很多变种，实现变种要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：

```java
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= key) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```

该实现和正常实现有以下不同：

- h 的赋值表达式为 h = m
- 循环条件为 l < h
- 最后返回 l 而不是 -1

在 nums[m] >= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。

在 h 的赋值表达式为 h = m 的情况下，如果循环条件为 l <= h，那么会出现循环无法退出的情况，因此循环条件只能是 l < h。以下演示了循环条件为 l <= h 时循环无法退出的情况：

```text
nums = {0, 1, 2}, key = 1
l   m   h
0   1   2  nums[m] >= key
0   0   1  nums[m] < key
1   1   1  nums[m] >= key
1   1   1  nums[m] >= key
...
```

当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。

### **1. [Leetcode69. x 的平方根[简单]](https://leetcode-cn.com/problems/sqrtx/)**

> 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
>
> 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
>
> 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
>
>  
>
> 示例 1：
>
> 输入：x = 4
> 输出：2
> 示例 2：
>
> 输入：x = 8
> 输出：2
> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
>



一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。

对于 x = 8，它的开方是 2.82842...，最后应该返回 2 而不是 3。在循环条件为 l <= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。

java提供的方法sqrt()

**思路**:
由于 x平方根的整数部分ans 是满足 k^2 ≤x 的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。

二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x的大小关系，并通过比较的结果调整上下界的范围。

```java
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
```


复杂度分析

时间复杂度：O(logx)，即为二分查找需要的次数。

空间复杂度：O(1)。

### 2.[Leetcode744. 寻找比目标字母大的最小字母[简单]](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

> 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。
>
> 在比较时，字母是依序循环出现的。举个例子：
>
> 如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a'
>
>
> 示例 1：
>
> 输入: letters = ["c", "f", "j"]，target = "a"
> 输出: "c"
> 示例 2:
>
> 输入: letters = ["c","f","j"], target = "c"
> 输出: "f"



实现：

```java
public char nextGreatestLetter(char[] letters, char target) {
    int n = letters.length;
    int l = 0, h = n - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (letters[m] <= target) {
            l = m + 1;
        } else {
            h = m - 1;
        }
    }
    return l < n ? letters[l] : letters[0];
}
```





### 3.[Leetcode540. 有序数组中的单一元素[中等]](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

> 给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。
>
> 请你找出并返回只出现一次的那个数。
>
> 你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。
>
>  示例 1:
>
> 输入: nums = [1,1,2,3,3,4,4,8,8]
> 输出: 2
>
> 示例 2:
>
> 输入: nums =  [3,3,7,7,10,11,11]
> 输出: 10



题目描述：一个有序数组只有一个数不出现两次，找出这个数。

要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。

令 index 为 Single Element 在数组中的位置。在 in	dex 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 < index，那么 nums[m] == nums[m + 1]；m + 1 >= index，那么 nums[m] != nums[m + 1]。

从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。

因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l < h 这种形式。

```java
public int singleNonDuplicate(int[] nums) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (m % 2 == 1) {
            m--;   // 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数
        }
        if (nums[m] == nums[m + 1]) {
            l = m + 2;
        } else {
            h = m;
        }
    }
    return nums[l];
}
```

### 4.[Leetcode278. 第一个错误的版本[简单]](https://leetcode-cn.com/problems/first-bad-version/)

> 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
>
> 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
>
> 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
>
>
> 示例 1：
>
> 输入：n = 5, bad = 4
> 输出：4
> 解释：
> 调用 isBadVersion(3) -> false 
> 调用 isBadVersion(5) -> true 
> 调用 isBadVersion(4) -> true
> 所以，4 是第一个错误的版本。
> 示例 2：
>
> 输入：n = 1, bad = 1
> 输出：1



题目描述：给定一个元素 n 代表有 [1, 2, ..., n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。

如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。

因为 h 的赋值表达式为 h = m，因此循环条件为 l < h。

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
}
```

### 5.[Leetcode153. 寻找旋转排序数组中的最小值[中等]](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

> 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
> 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
> 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
> 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
>
> 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
>
>  
>
> 示例 1：
>
> 输入：nums = [3,4,5,1,2]
> 输出：1
> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
> 示例 2：
>
> 输入：nums = [4,5,6,7,0,1,2]
> 输出：0
> 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
> 示例 3：
>
> 输入：nums = [11,13,15,17]
> 输出：11
> 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。





[Leetcode (opens new window)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/)

```html
Input: [3,4,5,1,2],
Output: 1
public int findMin(int[] nums) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] <= nums[h]) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return nums[l];
}
```



### 6.[Leetcode34. 在排序数组中查找元素的第一个和最后一个位置[中等]](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 target，返回 [-1, -1]。
>
> 进阶：
>
> 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
>
>
> 示例 1：
>
> 输入：nums = [5,7,7,8,8,10], target = 8
> 输出：[3,4]
> 示例 2：
>
> 输入：nums = [5,7,7,8,8,10], target = 6
> 输出：[-1,-1]

题目描述：给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。

可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找。我们将寻找 target 最后一个位置，转换成寻找 target+1 第一个位置，再往前移动一个位置。这样我们只需要实现一个二分查找代码即可。



**代码实现：**

```java
public int[] searchRange(int[] nums, int target) {
    int first = findFirst(nums, target);
    int last = findFirst(nums, target + 1) - 1;
    if (first == nums.length || nums[first] != target) {
        return new int[]{-1, -1};
    } else {
        return new int[]{first, Math.max(first, last)};
    }
}

private int findFirst(int[] nums, int target) {
    int l = 0, h = nums.length; // 注意 h 的初始值
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= target) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```

在寻找第一个位置的二分查找代码中，需要注意 h 的取值为 nums.length，而不是 nums.length - 1。先看以下示例：

```text
nums = [2,2], target = 2
```

如果 h 的取值为 nums.length - 1，那么 last = findFirst(nums, target + 1) - 1 = 1 - 1 = 0。这是因为 findLeft 只会返回 [0, nums.length - 1] 范围的值，对于 findFirst([2,2], 3) ，我们希望返回 3 插入 nums 中的位置，也就是数组最后一个位置再往后一个位置，即 nums.length。所以我们需要将 h 取值为 nums.length，从而使得 findFirst返回的区间更大，能够覆盖 target 大于 nums 最后一个元素的情况。



**图解：**

![img](https://assets.leetcode-cn.com/solution-static/34/1.png)
![img](https://assets.leetcode-cn.com/solution-static/34/2.png)
![img](https://assets.leetcode-cn.com/solution-static/34/3.png)
![img](https://assets.leetcode-cn.com/solution-static/34/4.png)
![img](https://assets.leetcode-cn.com/solution-static/34/5.png)
![img](https://assets.leetcode-cn.com/solution-static/34/6.png)
![img](https://assets.leetcode-cn.com/solution-static/34/7.png)
![img](https://assets.leetcode-cn.com/solution-static/34/8.png)
![img](https://assets.leetcode-cn.com/solution-static/34/9.png)
![img](https://assets.leetcode-cn.com/solution-static/34/10.png)
![img](https://assets.leetcode-cn.com/solution-static/34/11.png)
![img](https://assets.leetcode-cn.com/solution-static/34/12.png)
![img](https://assets.leetcode-cn.com/solution-static/34/13.png)![img](https://assets.leetcode-cn.com/solution-static/34/14.png)





### 7.[LeetCode704. 二分查找[简单]](https://leetcode-cn.com/problems/binary-search/)

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
>
> 示例 1:
>
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> 示例 2:
>
> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
> 解释: 2 不存在 nums 中因此返回 -1



**过程**：
设定左右指针
找出中间位置，并判断该位置值是否等于 target
nums[mid] == target 则返回该位置下标
nums[mid] > target 则右侧指针移到中间
nums[mid] < target 则左侧指针移到中间
时间复杂度：O(logN)O(logN)

**代码实现:**

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0){
            return -1;
        }
        int l = 0,r = nums.size() - 1;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                r = mid - 1;
            }else{
                l = mid + 1;
            }
        }
        return -1;
    }
};
```



 **画解:**

![img](https://pic.leetcode-cn.com/dfa84c120b44d64a9dbdc29f4fc659c4210365c5c03291039c3b1b10df80ac0f-frame_00001.png)
![img](https://pic.leetcode-cn.com/6955159a1a4c167f97955f66abd61e20861089e008dd86b26dc350677fc01a3e-frame_00002.png)
![img](https://pic.leetcode-cn.com/4ec5f9bacd8eda5ec91fb59fe2d937f792dc26a693db57130df010def1a8c859-frame_00003.png)
![img](https://pic.leetcode-cn.com/ca35b04c780fbb06fc640b180932acdfb4d9f58327c4018b59714dfc7cdda6bb-frame_00004.png)
![img](https://pic.leetcode-cn.com/9a153c4da08093f29c52b02c171b67dce8a27ddabba99545e4923d0589132250-frame_00005.png)
![img](https://pic.leetcode-cn.com/506b8c5a1fd8cb3d740e75e5274360bb1d90bff0d41c5850eec78a5480425b23-frame_00006.png)
![img](https://pic.leetcode-cn.com/277fb8c85cd3794e436b0be2470d12b3581cfbedfbc5512d76cc62e7f68cfc99-frame_00007.png)





### [8.LeetCode35. 搜索插入位置[简单]](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 O(log n) 的算法。
>
>  
>
> 示例 1:
>
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> 示例 2:
>
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1



**代码实现：**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```



**图解：**

![img](https://pic.leetcode-cn.com/5a0a4dcb1d8a219fa0107277c7913c4d7cce13827135453ec05f4143ac6a6074-frame_00001.png)
![img](https://pic.leetcode-cn.com/3af8dbf7c6fa8709696349cdfd55408a2c6d3bd2ab1bd7f6a4f6f304a961ede9-frame_00002.png)
![img](https://pic.leetcode-cn.com/918d4aac41675880f1a6aea7d01ee7ce462c9200cbc34d748ad2a205dfdf7f88-frame_00003.png)
![img](https://pic.leetcode-cn.com/d9568ad2f55a33524f19b2c8ce57e8459821c630fb9dfbc6b4a27d04c4ddfb60-frame_00004.png)
![img](https://pic.leetcode-cn.com/dfb8df989032749452ad09b9e7b91640bb836cedc8b1317b856511ae663ec019-frame_00005.png)





### [9.LeetCode162. 寻找峰值[中等]](https://leetcode-cn.com/problems/find-peak-element/)

> 峰值元素是指其值严格大于左右相邻值的元素。
>
> 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
>
> 你可以假设 nums[-1] = nums[n] = -∞ 。
>
> 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
>
>  
>
> 示例 1：
>
> 输入：nums = [1,2,3,1]
> 输出：2
> 解释：3 是峰值元素，你的函数应该返回其索引 2。
> 示例 2：
>
> 输入：nums = [1,2,1,3,5,6,4]
> 输出：1 或 5 
> 解释：你的函数可以返回索引 1，其峰值元素为 2；
>      或者返回索引 5， 其峰值元素为 6。



**代码实现：**

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        for (; left < right; ) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```

**图解：**

![img](https://pic.leetcode-cn.com/f1f214e320504a5f29a1cf2fa84ee3fd2ad09030527f444d7d488df7280f8eb7-frame_00001.png)

## 算法3.滑动窗口

**LeetCode209.长度最小的子数组**
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。



```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i = 0,j = 0,n = nums.size(),result = n + 1,sum = 0;
        while(j < n){
            sum += nums[j];
            while(sum >= target){
                result = min(result,j - i + 1);
                sum -= nums[i];
                i++;
            }
            j++;
        }
        return result == n + 1?0:result;
    }
};
```

**LeetCode1456.定长子串中元音的最大数目**
给你字符串 s 和整数 k 。
请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。
英文中的 元音字母 为（a, e, i, o, u）。

示例 1：
输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。



```cpp
class Solution {
public:
    int maxVowels(string s, int k) {
        if(s.size() == 0 || s.size() < k){
            return 0;
        }
        unordered_set<char> st = {'a','e','i','o','u'};
        int i,result = 0,count = 0;
        for(i = 0;i < k;i++){
            if(st.find(s[i]) != st.end()){
                count++;
            }
        }
        result = max(result,count);
        for(i = k;i < s.size();i++){
            if(st.find(s[i - k]) != st.end()){
                count--;
            }
            if(st.find(s[i]) != st.end()){
                count++;
            }
            result = max(result,count);
        }
        return result;
    }
};
```







## 算法4.递归

### **[1.LeetCode509.斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)**

> 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> F(0) = 0，F(1) = 1
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> 给定 n ，请计算 F(n) 。
>
>  
>
> 示例 1：
>
> 输入：n = 2
> 输出：1
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1

经典的兔子生成问题：

![img](https://img2.baidu.com/it/u=1297026355,72022086&fm=253&fmt=auto&app=138&f=PNG?w=500&h=450)





```cpp
   public static int fibonacci(int n) {
        if (n == 1 || n == 2) {     // 递归终止条件
            return 1;       // 简单情景
        }
        return fibonacci(n - 1) + fibonacci(n - 2); // 相同重复逻辑，缩小问题的规模
    }
```



**杨辉三角的取值**

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20200410%2Fceb23eeae6c44e67bd9321d801792c98.gif&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639912759&t=1be963dfb46e247b89b9955c9344cbd3)

```java
/**     
 * @description 递归获取杨辉三角指定行、列(从0开始)的值
 *              注意：与是否创建杨辉三角无关
    * @author rico 
     * @x  指定行
     * @y  指定列    
     */
  /**
    * Title: 杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。
    * 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。
    * 
    * 例如，下面给出了杨辉三角形的前4行： 
    *    1 
    *   1 1
    *  1 2 1
    * 1 3 3 1
    * @description 递归获取杨辉三角指定行、列(从0开始)的值
    *              注意：与是否创建杨辉三角无关
    * @author rico 
    * @x  指定行
    * @y  指定列  
    */
    public static int getValue(int x, int y) {
        if(y <= x && y >= 0){
            if(y == 0 || x == y){   // 递归终止条件
                return 1; 
            }else{ 
                // 递归调用，缩小问题的规模
                return getValue(x-1, y-1) + getValue(x-1, y); 
            }
        }
        return -1;
    } 
}
```



### **[2.LeetCode206.反转链表[简单]](https://leetcode-cn.com/problems/reverse-linked-list/)**

> 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
>
> 示例 1：
> [![img](https://img2020.cnblogs.com/blog/2415974/202106/2415974-20210606145609552-869361851.png)](https://img2020.cnblogs.com/blog/2415974/202106/2415974-20210606145609552-869361851.png)
>
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
>
> 



![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo8%2F21399d806bd142a5b45f1480153802e4.gif&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639918947&t=4d35a5249789105a1910bc3dc8d38e33)

```cpp
   public ListNode reverseList(ListNode head) {
 if (head == null || head.next == null) return head;
        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return p;
    }
```

### **[3.LeetCode344.反转字符串[简单]](https://leetcode-cn.com/problems/reverse-string/)**

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
> 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
> 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
>
> 示例 1：		
> 输入：["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]



```cpp
class Solution {
public:
    void recursion(vector<char>& s,int left,int right){
        if(left >= right){
            return;
        }
        recursion(s,left + 1,right - 1);
        int temp = s[left];
        s[left] = s[right];
        s[right] = temp;
    }
    void reverseString(vector<char>& s) {
        if(s.size() == 0){
            return;
        }
        int left = 0,right = s.size() - 1;
        recursion(s,left,right);
    }
};
```



### [4.Leetcode24. 两两交换链表中的节点[简单]](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

写递归的话，需要搞清楚递归的终止条件，以及递归函数内做什么。
下面以1->2->....来说明：
终止条件：当前节点为null，或者下一个节点为 null
函数内：将 2 指向 1，1 指向下一层的递归函数，最后返回节点 2
下面中t就表示函数内的临时节点 tmp，图中节点 1，节点 3 指向的一个片空白，这表示引用关系还没真正确定，要等下一层递归函数返回后，才能真正确定最终指向。

![递归.gif](http://pic.leetcode-cn.com/7ae491344608971d449add1e069aa143ee264b07a9bb8a1950e08dcf8d8a1ff9-%E9%80%92%E5%BD%92.gif)

我们来一一分析下，假设链表总长是偶数，那么递归函数执行到终止条件时，head 就等于 null。如果链表链表总长是偶数，那么递归函数执行到终止条件时，head.next 就等于 null。
递归函数内，我们要改变 1->2 的指向，将其改为 2->1。
那后面的节点怎么办呢？不用担心，这是由下一层递归函数来解决。下一层递归函数返回后的节点是 4，就是4->3->...这样的了，也就是后面的节点都已经串联好了。所以我们只需要将 1 节点指向 4 就可以啦。
代码如下：

```java
class Solution {
	public ListNode swapPairs(ListNode head) {
		//递归的终止条件
		if(head==null || head.next==null) {
			return head;
		}
		//假设链表是 1->2->3->4
		//这句就先保存节点2
		ListNode tmp = head.next;
		//继续递归，处理节点3->4
		//当递归结束返回后，就变成了4->3
		//于是head节点就指向了4，变成1->4->3
		head.next = swapPairs(tmp.next);
		//将2节点指向1
		tmp.next = head;
		return tmp;
	}
}
```

### [5.Leetcode21. 合并两个有序链表[简单]](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

> 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
>
> 示例 1：
>
> ![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F3026588-ebb4b042392e3463.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647871462&t=02c0e2e465bd1b8d3c99953a0cd64037)
>
> 输入：l1 = [1,2,4], l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]



**递归思想**

**终止条件**：当两个链表都为空时，表示我们对链表已合并完成。
**如何递归**：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Foscimg.oschina.net%2Foscnet%2Fb7c0f15c-83f8-4edc-bd76-d34dbc17deeb.gif&refer=http%3A%2F%2Foscimg.oschina.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1647871522&t=45b0dbcb0fba280c48d5fd5dec79c158)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        else if (l2 == null) {
            return l1;
        }
        else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
}

}
```



### [6.LeetCode104. 二叉树的最大深度[简单]](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> 说明: 叶子节点是指没有子节点的节点。
>
> 示例：
> 给定二叉树 [3,9,20,null,null,15,7]，
>
> ​    3
>
>    / \
>   9  20
>       /  \
>     15   7
> 返回它的最大深度 3 。

**方法一：深度优先搜索**

思路与算法

如果我们知道了左子树和右子树的最大深度 ll 和 rr，那么该二叉树的最大深度即为

>  max(l,r) + 1

而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            int leftHeight = maxDepth(root.left);
            int rightHeight = maxDepth(root.right);
            return Math.max(leftHeight, rightHeight) + 1;
        }
    }
}
```


复杂度分析

时间复杂度：O(n)，其中 nn 为二叉树节点的个数。每个节点在递归中只被遍历一次。

空间复杂度：O(height)，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。

**方法二：广度优先搜索**
思路与算法

我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量ans 来维护拓展的次数，该二叉树的最大深度即为 ans。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        int ans = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size > 0) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
                size--;
            }
            ans++;
        }
        return ans;
    }
}
```


复杂度分析

时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。

空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)O(n)。








## 算法5.分治法

**LeetCode169.多数元素**
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1：
输入：[3,2,3]
输出：3



```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) 
    {
        return getMajority(nums,0,nums.size() - 1);
    }
    int getMajority(vector<int>&nums,int left,int right)
    {
        if(left == right)
            return nums[left];
        int mid = left + (right - left) / 2;
        int leftMajority = getMajority(nums,left,mid);
        int rightMajority = getMajority(nums,mid + 1,right);
        if(leftMajority == rightMajority)
            return leftMajority;
        int leftcount = 0,rightcount = 0;
        for(int i = left;i <= right;i++)
        {
            if(nums[i] == leftMajority)
            {
                leftcount++;
            }
            else if(nums[i] == rightMajority)
            {
                rightcount++;
            }  
        }
        if(leftcount > rightcount)
        { 
            return leftMajority;
        }
        else
        {
            return rightMajority;
        }
    }
};
```

**LeetCode53.最大子序和**
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。



```cpp
class Solution {
private:
    int getMax(vector<int>& nums,int left,int right){
        if(left == right){
            return nums[left];
        }
        int mid = left + (right - left) / 2;
        int leftMax = getMax(nums,left,mid);
        int rightMax = getMax(nums,mid + 1,right);
        int crossMax = getCrossMax(nums,left,right);
        return max(max(leftMax,rightMax),crossMax);
    }
    int getCrossMax(vector<int>& nums,int left,int right){
        int mid = left + (right - left) / 2;
        int leftSum = nums[mid];
        int leftMax = leftSum;
        for(int i = mid - 1;i >= left;i--){
            leftSum +=nums[i];
            leftMax = max(leftMax,leftSum);
        }
    int rightSum = nums[mid + 1];
    int rightMax = rightSum;
    for(int i = mid + 2;i <= right;i++){
        rightSum += nums[i];
        rightMax = max(rightMax,rightSum);
    }
    return leftMax + rightMax;
    }
public:
    int maxSubArray(vector<int>& nums) {
        return getMax(nums,0,nums.size() - 1);
    }
};
```

## 算法6.回溯法

**LeetCode22. 括号生成**
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例 1：
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]



```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) 
    {
        vector<string> result;
        string cur;
        backtracking(n,result,0,0,cur);
        return result;
    }
    void backtracking(int n,vector<string>& result,int left,int right,string& cur)
    {
        if(right > left)
            return;
        if(cur.size() == n * 2)
        {
            result.push_back(cur);
            return;
        }
        if(left < n)
        {
            cur.push_back('(');
            backtracking(n,result,left + 1,right,cur);
            cur.pop_back();
        }
        if(right < left)
        {
            cur.push_back(')');
            backtracking(n,result,left,right + 1,cur); 
            cur.pop_back();
        }
    }
};
```

**LeetCode78. 子集**
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

三种解法：
1.扩展法



```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>>result;
        result.push_back(*new vector<int>());
        for(int num:nums){
            vector<vector<int>> subset;
            for(auto res:result){
                vector<int> temp = *new vector<int>(res);
                temp.push_back(num);
                subset.push_back(temp);
            }
            for(auto t:subset){
                result.push_back(t);
                }
        }
        return result;
    }
};
```

2.回溯法



```cpp
class Solution {
public:
    vector<vector<int>>result;
    void backtracking(vector<int> nums,int length,int index,vector<int> subset){
        if(subset.size() == length){
            vector<int> temp = *new vector<int>(subset);
            result.push_back(temp);
            return;
        }
        for(int i = index;i < nums.size();i++){
            subset.push_back(nums[i]);
            backtracking(nums,length,i+1,subset);
            subset.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        result.push_back(*new vector<int>());
        for(int i = 1;i <= nums.size();i++){
            backtracking(nums,i,0,*new vector<int>());
        }
        return result;
    }
};
```

3.dfs



```
class Solution {
public:
    vector<vector<int>>result;
    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(nums,0,*new vector<int>());
        return result;
    }
    void dfs(vector<int>& nums,int index,vector<int> subset){
        result.push_back(subset);
        if(index == nums.size()){
            return;
        }
        for(int i = index;i < nums.size();i++){
            subset.push_back(nums[i]);
            dfs(nums,i + 1,subset);
            subset.pop_back();
        }
    }
};
```

## 算法7.深度优先搜索算法DFS

**LeetCode938.二叉搜索树的范围和**
给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
[![img](https://img2020.cnblogs.com/blog/2415974/202106/2415974-20210622110931592-624695570.png)](https://img2020.cnblogs.com/blog/2415974/202106/2415974-20210622110931592-624695570.png)

示例 1：
输入：root = [10,5,15,3,7,null,18], low = 7, high = 15
输出：32
1.递归法



```cpp
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high){
        if(root == nullptr)
            return 0;
        int leftsum = rangeSumBST(root -> left,low,high);
        int rightsum = rangeSumBST(root -> right,low,high);
        int result = leftsum + rightsum;
        if(root -> val >= low && root -> val <= high)
            result = result + root -> val;
        return result;
    }
};
```

2.BFS



```cpp
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) 
    {
        int result = 0;
        queue<TreeNode*>q;
        q.push(root);
        while(q.size()>0)
        {
            int size = q.size();
            while(size > 0)
            {
                auto cur = q.front();
                q.pop();
                if(cur -> val >= low && cur ->val <= high)
                {
                    result += cur -> val;
                }
                if(cur -> left != NULL)
                {
                    q.push(cur -> left);
                }
                if(cur -> right != NULL)
                {
                    q.push(cur -> right);
                }
                size--;
            }
        }
        return result;
    }
};
```

3.DFS



```cpp
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if(root == nullptr)
            return 0;
        if(root -> val > high)                          //比high值大就去左子树，寻找比high小的值
            return rangeSumBST(root -> left,low,high);
        if(root -> val < low)                           //比low值小就去右子树，寻找比low大的值
            return rangeSumBST(root -> right,low,high);
        return root -> val + rangeSumBST(root -> left,low,high) + rangeSumBST(root -> right,low,high);  //将符合条件的值相加即得结果
    }
};
```

## 算法8.广度优先搜索算法BFS

**LeetCode102. 二叉树的层序遍历**
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例：
二叉树：[3,9,20,null,null,15,7],
3
/
9 20
/
15 7
返回其层序遍历结果：

[
[3],
[9,20],
[15,7]
]
1.BFS



```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) 
    {
        vector<vector<int>> result;
        if(root == nullptr)
            return result;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int size = q.size();
            result.push_back(vector<int>());
            for(int i = 0;i < size;i++)
            {
                auto temp = q.front();
                q.pop();
                result.back().push_back(temp -> val);
                if(temp -> left != NULL)
                {
                    q.push(temp -> left);
                }
                if(temp -> right != NULL)
                {
                    q.push(temp -> right);
                }
            }
        }
        return result;
    }
};
```

2.DFS



```cpp
class Solution {
public:
    void dfs(TreeNode *node,vector<vector<int>>&result,int level)
    {
        if(node == nullptr)
            return;
        if(level >= result.size())
            result.push_back(vector<int>());
        result[level].push_back(node -> val);
        if(node -> left != NULL)
            dfs(node -> left,result,level + 1);
        if(node -> right != NULL)
            dfs(node -> right,result,level + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) 
    {
        vector<vector<int>>result;
        if(root == nullptr)
            return result;
        dfs(root,result,0);
        return result;
    }
};
```

## 算法9.并查集

**LeetCode200. 岛屿数量**
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

示例 1：
输入：grid = [
["1","1","1","1","0"],
["1","1","0","1","0"],
["1","1","0","0","0"],
["0","0","0","0","0"]
]
输出：1
1.DFS



```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) 
    {
        if(grid[0][0] == NULL || grid.size() == 0)
        {
            return 0;
        }
        int result = 0;
        int row = grid.size();
        int col = grid[0].size();
        for(int i = 0;i < row;i++)
        {
            for(int j = 0;j < col;j++)
            {
                if(grid[i][j] == '1')
                {
                    result += 1;
                    dfs(grid,i,j,row,col);
                }
            }
        }
        return result;
    }
    void dfs(vector<vector<char>>&grid,int i,int j,int row,int col)
    {
        if(i < 0 || j < 0 || i >= row || j >= col || grid[i][j] == '0')
            return;
        grid[i][j] = '0';
        dfs(grid,i + 1,j,row,col);
        dfs(grid,i - 1,j,row,col);
        dfs(grid,i,j - 1,row,col);
        dfs(grid,i,j + 1,row,col);
    }
};
```

2.BFS



```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) 
    {
        if(grid[0][0] == NULL || grid.size() == 0)
            return 0;
        int result = 0;
        int row = grid.size();
        int col = grid[0].size();
        queue<pair<int,int>> q;
        for(int i = 0;i < row;i++)
        {
            for(int j = 0;j < col;j++)
            {
                if(grid[i][j] == '1')
                {
                    result += 1;
                    q.push({i,j});
                    grid[i][j] = '0';
                    while(!q.empty())
                    {
                        auto cur = q.front();
                        q.pop();
                        int x = cur.first,y = cur.second;
                        if(x - 1 >= 0 && grid[x - 1][y] == '1')
                        {
                            grid[x - 1][y] = '0';
                            q.push({x - 1,y});
                        }
                        if(y - 1 >= 0 && grid[x][y - 1] == '1')
                        {
                            grid[x][y - 1] = '0';
                            q.push({x,y - 1});
                        }
                        if(x + 1 < row && grid[x + 1][y] == '1')
                        {
                            grid[x + 1][y] = '0';
                            q.push({x + 1,y});
                        }
                        if(y + 1 < col && grid[x][y + 1] == '1')
                        {
                            grid[x][y + 1] = '0';
                            q.push({x ,y + 1});
                        }
                    }
                }
            }
        }
        return result;
    }
};
```

3.并查集



```cpp
class UnionFind{
    public:
    UnionFind(vector<vector<char>>& grid)
    {
        int row = grid.size();
        int col = grid[0].size();
        count = row * col;
        root = vector<int>(row * col , 0);
        for(int i = 0; i < row*col; i++) 
        {
            root[i] = i;
        } 
    }
    int find(int x)
    {
        if(x == root[x])
        {
            return x;
        }
        else
        {
            root[x] = find(root[x]);
            return root[x];
        }
    }
    void Union(int x,int y)
    {
        int rootx = find(x);
        int rooty = find(y);
        if(rootx != rooty)
        {
            root[rootx] = rooty;
            count--;
        }
    }
    int getCount()
    {
        return count;
    }
private:
vector<int> root;
int count = 0;
};
        
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) 
    {
        if(!grid.size())
        {
            return 0;
        }
        int row = grid.size();
        int col = grid[0].size();
        int water = 0;
        auto uf  = UnionFind(grid);
        for(int i = 0;i < row;i++)
        {
            for(int j = 0;j < col;j++)
            {
                if(grid[i][j] == '0')
                {
                    water++;
                }
                else
                {
                    vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
                    for(auto d:directions)
                    {
                        int x = i + d[0];
                        int y = j + d[1];
                        if(x >= 0 && x < row && y >= 0 && y < col && grid[x][y] == '1')
                        {
                            uf.Union(x * col + y,i * col + j);
                        }
                    }
                }
            }
        }
        return uf.getCount() - water;
    }
};
```

## 算法10.贪心算法

保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。

### 1. 分配饼干

455. Assign Cookies (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/assign-cookies/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/assign-cookies/description/)

```html
Input: grid[1,3], size[1,2,4]
Output: 2
```

题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。

1. 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。
2. 因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。

在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。

证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m < n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e69537d2-a016-4676-b169-9ea17eeb9037.gif)



```java
public int findContentChildren(int[] grid, int[] size) {
    if (grid == null || size == null) return 0;
    Arrays.sort(grid);
    Arrays.sort(size);
    int gi = 0, si = 0;
    while (gi < grid.length && si < size.length) {
        if (grid[gi] <= size[si]) {
            gi++;
        }
        si++;
    }
    return gi;
}
```

### 2. 不重叠的区间个数

435. Non-overlapping Intervals (Medium)

[Leetcode (opens new window)](https://leetcode.com/problems/non-overlapping-intervals/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/non-overlapping-intervals/description/)

```html
Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

题目描述：计算让一组区间不重叠所需要移除的区间个数。

先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。

在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。

按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。

```java
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) {
        return 0;
    }
    Arrays.sort(intervals, Comparator.comparingInt(o -> o[1]));
    int cnt = 1;
    int end = intervals[0][1];
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < end) {
            continue;
        }
        end = intervals[i][1];
        cnt++;
    }
    return intervals.length - cnt;
}
```

使用 lambda 表示式创建 Comparator 会导致算法运行时间过长，如果注重运行时间，可以修改为普通创建 Comparator 语句：

```java
Arrays.sort(intervals, new Comparator<int[]>() {
     @Override
     public int compare(int[] o1, int[] o2) {
         return (o1[1] < o2[1]) ? -1 : ((o1[1] == o2[1]) ? 0 : 1);
     }
});
```

实现 compare() 函数时避免使用 `return o1[1] - o2[1];` 这种减法操作，防止溢出。

### 3. 投飞镖刺破气球

452. Minimum Number of Arrows to Burst Balloons (Medium)

[Leetcode (opens new window)](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

```text
Input:
[[10,16], [2,8], [1,6], [7,12]]

Output:
2
```

题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。

也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。

```java
public int findMinArrowShots(int[][] points) {
    if (points.length == 0) {
        return 0;
    }
    Arrays.sort(points, Comparator.comparingInt(o -> o[1]));
    int cnt = 1, end = points[0][1];
    for (int i = 1; i < points.length; i++) {
        if (points[i][0] <= end) {
            continue;
        }
        cnt++;
        end = points[i][1];
    }
    return cnt;
}
```

### 4. 根据身高和序号重组队列

406. Queue Reconstruction by Height(Medium)

[Leetcode (opens new window)](https://leetcode.com/problems/queue-reconstruction-by-height/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/)

```html
Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。

为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。

身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。

```java
public int[][] reconstructQueue(int[][] people) {
    if (people == null || people.length == 0 || people[0].length == 0) {
        return new int[0][0];
    }
    Arrays.sort(people, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]));
    List<int[]> queue = new ArrayList<>();
    for (int[] p : people) {
        queue.add(p[1], p);
    }
    return queue.toArray(new int[queue.size()][]);
}
```

### 5. 买卖股票最大的收益

121. Best Time to Buy and Sell Stock (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/)

题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。

只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。

```java
public int maxProfit(int[] prices) {
    int n = prices.length;
    if (n == 0) return 0;
    int soFarMin = prices[0];
    int max = 0;
    for (int i = 1; i < n; i++) {
        if (soFarMin > prices[i]) soFarMin = prices[i];
        else max = Math.max(max, prices[i] - soFarMin);
    }
    return max;
}
```

### 6. 买卖股票的最大收益 II

122. Best Time to Buy and Sell Stock II (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。

对于 [a, b, c, d]，如果	有 a <= b <= c <= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] > 0，那么就把 prices[i] - prices[i-1] 添加到收益中。

```java
public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            profit += (prices[i] - prices[i - 1]);
        }
    }
    return profit;
}
```

### 7. 种植花朵

605. Can Place Flowers (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/can-place-flowers/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/can-place-flowers/description/)

```html
Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
```

题目描述：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。

```java
public boolean canPlaceFlowers(int[] flowerbed, int n) {
    int len = flowerbed.length;
    int cnt = 0;
    for (int i = 0; i < len && cnt < n; i++) {
        if (flowerbed[i] == 1) {
            continue;
        }
        int pre = i == 0 ? 0 : flowerbed[i - 1];
        int next = i == len - 1 ? 0 : flowerbed[i + 1];
        if (pre == 0 && next == 0) {
            cnt++;
            flowerbed[i] = 1;
        }
    }
    return cnt >= n;
}
```

### 8. 判断是否为子序列

392. Is Subsequence (Medium)

[Leetcode (opens new window)](https://leetcode.com/problems/is-subsequence/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/is-subsequence/description/)

```html
s = "abc", t = "ahbgdc"
Return true.
public boolean isSubsequence(String s, String t) {
    int index = -1;
    for (char c : s.toCharArray()) {
        index = t.indexOf(c, index + 1);
        if (index == -1) {
            return false;
        }
    }
    return true;
}
```

### 9. 修改一个数成为非递减数组

665. Non-decreasing Array (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/non-decreasing-array/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/non-decreasing-array/description/)

```html
Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
```

题目描述：判断一个数组是否能只修改一个数就成为非递减数组。

在出现 nums[i] < nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 **不影响后续的操作** 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] < nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。

```java
public boolean checkPossibility(int[] nums) {
    int cnt = 0;
    for (int i = 1; i < nums.length && cnt < 2; i++) {
        if (nums[i] >= nums[i - 1]) {
            continue;
        }
        cnt++;
        if (i - 2 >= 0 && nums[i - 2] > nums[i]) {
            nums[i] = nums[i - 1];
        } else {
            nums[i - 1] = nums[i];
        }
    }
    return cnt <= 1;
}
```

### 10. 子数组最大的和

53. Maximum Subarray (Easy)

[Leetcode (opens new window)](https://leetcode.com/problems/maximum-subarray/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/maximum-subarray/description/)

```html
For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int preSum = nums[0];
    int maxSum = preSum;
    for (int i = 1; i < nums.length; i++) {
        preSum = preSum > 0 ? preSum + nums[i] : nums[i];
        maxSum = Math.max(maxSum, preSum);
    }
    return maxSum;
}
```

### 11. 分隔字符串使同种字符出现在一起

763. Partition Labels (Medium)

[Leetcode (opens new window)](https://leetcode.com/problems/partition-labels/description/)/ [力扣(opens new window)](https://leetcode-cn.com/problems/partition-labels/description/)

```html
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
public List<Integer> partitionLabels(String S) {
    int[] lastIndexsOfChar = new int[26];
    for (int i = 0; i < S.length(); i++) {
        lastIndexsOfChar[char2Index(S.charAt(i))] = i;
    }
    List<Integer> partitions = new ArrayList<>();
    int firstIndex = 0;
    while (firstIndex < S.length()) {
        int lastIndex = firstIndex;
        for (int i = firstIndex; i < S.length() && i <= lastIndex; i++) {
            int index = lastIndexsOfChar[char2Index(S.charAt(i))];
            if (index > lastIndex) {
                lastIndex = index;
            }
        }
        partitions.add(lastIndex - firstIndex + 1);
        firstIndex = lastIndex + 1;
    }
    return partitions;
}

private int char2Index(char c) {
    return c - 'a';
}
```



**LeetCode322.零钱兑换**
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
贪心+动态规划：



```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) 
    {
        vector<int>dp(amount + 1, -1);
        dp[0] = 0;
        for(int i = 1;i <= amount;i++)
        {
            for(int j = 0;j < coins.size();j++)
            {
                if(coins[j] <= i && dp[i - coins[j]] != -1)
                {
                    if(dp[i] == -1 || dp[i] > dp[i - coins[j]] + 1)
                    {
                        dp[i] = dp[i - coins[j]] + 1;
                    }
                }
            }
        }
        return dp[amount];
    }
};
```

## 算法11.动态规划

**LeetCode509.斐波那契数**
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n) 。

示例 1：
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1



```cpp
class Solution {
public:
    int fib(int n) {
        if(n < 2){
            return n == 1?1:0;
        }
        int sum = fib(n - 1) + fib(n - 2);
        return sum;
    }
};
```

**LeetCode62.不同路径**
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？
示例 1：
[![img](https://img2020.cnblogs.com/blog/2415974/202107/2415974-20210701100520509-1492354359.png)](https://img2020.cnblogs.com/blog/2415974/202107/2415974-20210701100520509-1492354359.png)
输入：m = 3, n = 7
输出：28



```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m + 1,vector<int>(n + 1));
        dp[0][0] = 1;
        dp[0][1] = 1;
        for(int i = 1;i <= m;i++)
        {
            for(int j = 1;j <= n;j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
};
```

## 算法12.字典树Trie

**LeetCode208.实现Trie（前缀树）**
Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
请你实现 Trie 类：
Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

示例：
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple"); // 返回 True
trie.search("app"); // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app"); // 返回 True



```cpp
class Trie {
private:
    bool isEnd;
    Trie *next[26];
public:
    /** Initialize your data structure here. */
    Trie() {
        isEnd = false;
        memset(next,0,sizeof(next));
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie *node = this;
        for(char c:word){
            if(node -> next[c - 'a'] == NULL){
                node -> next[c - 'a'] = new Trie();
            }
            node = node -> next[c - 'a'];
        }
        node -> isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie *node = this;
        for(char c:word){
            node = node -> next[c - 'a'];
            if(node == NULL){
                return false;
            }
        }
        return node -> isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie *node = this;
        for(char c:prefix){
            node = node -> next[c - 'a'];
            if(node == NULL){
                return false;
            }
        }
        return true;
    }
};
```

# 二、排序算法



![img](https://img-blog.csdnimg.cn/20200616131228456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk0OTEzNQ==,size_16,color_FFFFFF,t_70)

### 插入、冒泡、归并、快排时间复杂度和空间复杂度

| 排序方法 | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性 | 复杂性 |
| -------- | ------------------ | ------------------ | ------------------ | ---------- | ------ | ------ |
| 插入排序 | O(n2)              | O(n2)              | O(n)               | O(1)       | 稳定   | 简单   |
| 冒泡排序 | O(n2)              | O(n2)              | O(n)               | O(1)       | 不稳定 | 较复杂 |
| 归并排序 | O(nlog2n)          | O(nlog2n)          | O(nlog2n)          | O(n)       | 稳定   | 较复杂 |
| 快速排序 | O(nlog2n)          | O(n2)              | O(nlog2n)          | O(nlog2n)  | 不稳定 | 较复杂 |



### 1. 插入排序

```java
/**
     * 插入排序的
     * 1.时间复杂度为O(n^2)
     * 2. O(1)的额外空间的排序
     * 3. 平均情况为O(n*n)
     *
     * @param array
     * @return
     */
    public static int[] insertSort(int[] array) {
        for (int index = 0; index < array.length; index++) {
            int temp = array[index];  //将index位的数据拿出来，放到临时变量里，这时index位置就空出来了.
            int leftIndex = index - 1;
            while (leftIndex >= 0 && array[leftIndex] > temp) {  //开始将左面的数据与当前index位的数据（即temp）进行比较
                array[leftIndex + 1] = array[leftIndex];
                leftIndex--;
            }
            array[leftIndex + 1] = temp;
        }
        return array;
    }

```

### 2.冒泡排序

```java
/**
     * 冒泡排序
     * 最优的时间复杂度为：O( n^2 )
     * 最差的时间复杂度为：O( n^2 )；
     * 平均的时间复杂度为：O( n^2 )；
     * 平均的空间复杂度为：O(1)；
     *
     * @param array
     */
    public static void sort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }

```

### 3.归并排序

```java
/**
     * 归并排序 归并排序是一种稳定的排序。
     * 可用顺序存储结构。也易于在链表上实现。o
     * 对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。
     * 需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。
     *
     * @param array
     * @param low
     * @param mid
     * @param high
     */
    public static void mergeArray(int[] array, int low, int mid, int high) {
        int[] temp = new int[array.length];
        int i = low;  //i右数组第一个元素索引
        int j = mid + 1;  //j左数组的第一个元素索引
        int k = 0;// k 记录临时数组的索引
        // 从两个数组中取出最小的放入临时数组
        while (i <= mid && j <= high) {
            if (array[i] > array[j]) temp[k++] = array[j++];
            else temp[k++] = array[i++];
        }
        // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）
        while (i <= mid) temp[k++] = array[i++];
        while (j <= high) temp[k++] = array[j++];
        // 将临时数组中的内容拷贝回原数组中
        for (int x = 0; x < k; x++) array[x + low] = temp[x];
    }

    public static void mergeSort(int[] array, int low, int high) {
        if (low < high) {
            int mid = (low + high) / 2;            // 找出中间索引
            mergeSort(array, low, mid);            // 对左边数组进行递归
            mergeSort(array, mid + 1, high);  // 对右边数组进行递归
            mergeArray(array, low, mid, high);     // 合并
        }
    }

```

### 4. 快速排序

```java
/**
     * 快排
     * 快排在最糟糕得情况下时间复杂度是O(n²)，平均的复杂度是O(nlogn)
     * 主要是递归造成的栈空间的使用，最好情况，递归树的深度为log2n，
     * 其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。
     * @param array
     * @param low
     * @param high
     * @return
     */
    public static int getIndex(int[] array, int low, int high) {
        int temp = array[low]; //记录一个标值的值
        while (low < high) {
            while (low < high && array[high] > temp) high--; //1. 队尾元素大于基准元素的时候 high--
            array[low] = array[high];                      // 如果队尾元素小于tmp了,需要将其赋值给low
            while (low < high && array[low] < temp) low++;  //2. 队首元素小于基准元素的时候 low++
            array[high] = array[low];                        // 当队首元素大于tmp时,需要将其赋值给high
        }
        array[low] = temp;
        return low;
    }

    public static void quickSort(int[] array, int low, int high) {
        if (low < high) {
            int index = getIndex(array, low, high);
            quickSort(array, low, index - 1);
            quickSort(array, index + 1, high);
        }
    }
	
```

### 5.测试数据

```java
public static void main(String[] args) {
        int[] array = {38, 65, 97, 76, 13, 27, 49};
        insertSort(array);
        System.out.print("插入排序从小到大排序后的结果是:");
        for (Integer i : array) {
            System.out.print(i + " ");
        }
        System.out.println();
        int[] array1 = {38, 65, 97, 76, 13, 27, 49};
        sort(array1);
        System.out.print("冒泡排序从小到大排序后的结果是:");
        for (Integer i : array1) {
            System.out.print(i + " ");
        }
        System.out.println();
        int[] array2 = {38, 65, 97, 76, 13, 27, 49};
        mergeSort(array2, 0, array2.length - 1);
        System.out.print("归并排序从小到大排序后的结果是:");
        for (Integer i : array2) {
            System.out.print(i + " ");
        }
        System.out.println();
        int[] array3 = {38, 65, 97, 76, 13, 27, 49};
        quickSort(array3, 0, array3.length - 1);
        System.out.print("快速排序从小到大排序后的结果是:");
        for (Integer i : array3) {
            System.out.print(i + " ");
        }
    }

```

