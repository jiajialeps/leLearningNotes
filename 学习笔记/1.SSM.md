### 一、SpringMVC:

**Spring MVC的工作原理是怎样的**

**在将SpringMVC之前我们先来看一下什么是MVC模式**

MVC：MVC是一种设计模式

#### 1）MVC的原理图：

![](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/MVC.png)

M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）

V-View 视图（做界面的展示  jsp，html……）

C-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）

#### 2）SpringMVC框架结构

![img](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/SpringMVC.png)

背诵口诀：上映下适

**看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解）**

第一步:用户发起请求到前端控制器（DispatcherServlet）

第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找

第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain）

第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）

第五步：处理器适配器去执行Handler

第六步：Handler执行完给处理器适配器返回ModelAndView

第七步：处理器适配器向前端控制器返回ModelAndView

第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析

第九步：视图解析器像前端控制器返回View

第十步：前端控制器对视图进行渲染

第十一步：前端控制器向用户响应结果

**看到这些步骤我相信大家很感觉非常的乱，这是正常的，但是这里主要是要大家理解springMVC中的几个组件：**

前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。

处理器映射器（HandlerMapping）：根据URL去查找处理器

处理器（Handler）：（需要程序员去写代码处理逻辑的）

处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）

视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面

####  3）拦截器（Interceptor） vs 过滤器（Filter）

| 比较项                   | 拦截器（Interceptor）                    | 过滤器（Filter）                                    |
| ------------------------ | ---------------------------------------- | --------------------------------------------------- |
| **作用范围**             | 仅拦截 **Spring MVC Controller 请求**    | 拦截 **所有请求（包括静态资源）**                   |
| **实现接口**             | `HandlerInterceptor`（Spring 提供）      | `javax.servlet.Filter`（Servlet 规范）              |
| **执行时机**             | 在 `DispatcherServlet` 解析 Handler 之前 | 在 `Servlet 容器` 解析请求之前                      |
| **是否依赖 Spring**      | 是（Spring MVC 特有）                    | 否（Servlet 规范，可用于任何 Java Web 项目）        |
| **能否获取 Spring Bean** | 可以                                     | 不能直接获取（需要手动注入）                        |
| **适合的用途**           | **权限控制、日志记录、参数预处理**       | **编码处理、权限校验、跨域（CORS）、防止 SQL 注入** |
| **是否能修改响应**       | 不能                                     | 可以                                                |


![img](https://images2017.cnblogs.com/blog/330611/201710/330611-20171023150730676-300068307.png)



### 二、Bean生命周期

4大步骤：实例化 -> 属性赋值 -> 初始化 -> 销毁

1.以ApplocationContext上下文单例模式装配bean为例，深入探讨bean的生命周期：

![img](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/SingleSpringBean.png)





2.以Spring Factory装配bean为例：

![img](https://gitee.com/jiajiales/learningNotes/raw/master/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/media/FactorySpringBean.png)





#### 1）可以简述为以下九步

1.实例化bean对象(通过构造方法或者工厂方法)

2.设置对象属性(setter等)（依赖注入）

3.如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口）

4.如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身

5.将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法

6.调用Bean的初始化方法

7.将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法

8.使用Bean		

9.容器关闭之前，调用Bean的销毁方法

#### **2）线性安全问题：**

对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。

对于原型(prototype)Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。

bean默认是单例的所以是线程不安全的

Bean 、controller、service和dao层本身都不是线程安全的

 因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的（prototype：多例）。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。 

详细点的文档：https://www.cnblogs.com/myseries/p/11729800.html



#### 3）spring中Bean的作用域

**1. singleton：** Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域。

**2. prototype：** 每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。

**3. request：** 在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。

**4. session：** 在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。

**5. global Session：** 在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。

### **三、SpringBoot的启动流程:**

**1.当我们启动SpringBoot的时候，先动用启动类中的静态run方法**

[![img](https://img2020.cnblogs.com/blog/2105697/202105/2105697-20210514003937330-1664256001.jpg)](https://img2020.cnblogs.com/blog/2105697/202105/2105697-20210514003937330-1664256001.jpg)

**2.run方法中最重要的两个环节**  
a.创建 ApplicationContext容器  
b.刷新 ApplicationContext容器  

**3.在刷新容器的时候会去解析启动类，而启动类的注解使用的是@SpringBootApplication。**

这是一个复合注解，里面包含了@EnableAutoConfiguration，@Configuration，@ComponentScan这三个注解

* @EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置
* @Configuration：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境
* @ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下

**4.三个注解中，@EnableAutoConfiguration会开启自动配置，同时会去依赖的包中寻找spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包**。

**5.将jar包中的自动配置类加到容器中并进行实例化，完成自动装配。**

### 四、Spring

#### 1.说说Spring 里用到了哪些设计模式?

`单例模式`：Spring 中的 Bean 默认情况下都是单例的。无需多说。

`工厂模式`：工厂模式主要是通过 BeanFactory 和 ApplicationContext 来生产 Bean 对象。

`代理模式`：最常见的 AOP 的实现方式就是通过代理来实现，Spring主要是使用 JDK 动态代理和 CGLIB 代理。

`模板方法模式`：主要是一些对数据库操作的类用到，比如 JdbcTemplate、JpaTemplate，因为查询数据库的建立连接、执行查询、关闭连接几个过程，非常适用于模板方法。

#### 2.谈谈你对IOC 和 AOP 的理解？他们的实现原理是什么？

 **IOC 和 AOP 的核心区别**

| **对比项**       | **IOC（控制反转）**                             | **AOP（面向切面编程）**                  |
| ---------------- | ----------------------------------------------- | ---------------------------------------- |
| **作用**         | **管理对象的创建和依赖**                        | **增强方法功能，减少重复代码**           |
| **核心思想**     | 通过 **依赖注入（DI）** 让 Spring 容器控制 Bean | 通过 **代理机制** 在方法执行前后添加逻辑 |
| **实现方式**     | `@Autowired` 依赖注入                           | JDK 代理 / CGLIB 代理 / AspectJ          |
| **影响范围**     | **整个应用的对象管理**                          | **特定方法的执行过程**                   |
| **使用场景**     | Bean 依赖注入、管理对象生命周期                 | 事务、日志、权限、监控等                 |
| **底层原理**     | **工厂模式**、**反射**                          | **代理模式**                             |
| **是否需要代理** | **不需要**                                      | **需要**                                 |
| **典型注解**     | `@Component`、`@Service`                        | `@Aspect`、`@Before`、`@Around`          |

 **总结**

- **IOC 负责对象创建和依赖管理，AOP 负责增强方法行为**
- **IOC 让代码解耦，AOP 让代码更简洁**
- **二者结合，使 Spring 既能高效管理对象，又能灵活增强功能**
#### 3. JDK 动态代理和 CGLIB 代理有什么区别？

- **核心区别**

   - **JDK 动态代理**：基于 **Java 反射机制** 和 `InvocationHandler`，只能代理 **接口**。
   - **CGLIB 代理**：基于 **字节码增强（ASM）**，可以代理 **类和方法**（即没有实现接口的类也可以代理）。

 **详细对比（表格）**

| 对比项             | JDK 动态代理                                           | CGLIB 代理                                   |
| ------------------ | ------------------------------------------------------ | -------------------------------------------- |
| **原理**           | 反射 + `Proxy` + `InvocationHandler`                   | 继承被代理类 + ASM 字节码操作                |
| **代理对象**       | 只能代理 **实现了接口** 的类                           | 可以代理 **没有实现接口** 的类               |
| **性能**           | 由于基于 **反射**，性能稍低                            | 由于直接修改 **字节码**，性能更高            |
| **JDK 依赖**       | **必须** 依赖接口 (`Proxy.newProxyInstance`)           | **不依赖** 接口，可以代理普通类              |
| **子类生成**       | 不会生成子类，直接通过 `Proxy` 生成代理对象            | 生成 **被代理类的子类** 进行增强             |
| **final 方法支持** | **不支持**（接口中的 `final` 方法无法代理）            | **不支持**（`final` 方法无法被增强）         |
| **使用场景**       | 适用于 **接口代理**，如 `Spring AOP` 代理 Service 接口 | 适用于 **普通类代理**，如 Hibernate、MyBatis |

在 **Spring AOP** 中：

- 如果 **类实现了接口**，默认使用 **JDK 动态代理**。
- 如果 **类没有实现接口**，Spring 采用 **CGLIB 代理**。


#### 4. Spring AOP 和 AspectJ AOP 有什么区别？
| **对比维度**               | **Spring AOP**                                             | **AspectJ AOP**                                              |
| -------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **实现方式**               | **基于代理**（JDK 动态代理 & CGLIB）                       | **基于字节码增强**（修改字节码）                             |
| **增强方式**               | **运行时增强**（Runtime Weaving）                          | **编译时增强（Compile-Time Weaving, CTW）<br>类加载时增强（Load-Time Weaving, LTW）<br>运行时增强（Runtime Weaving）** |
| **织入（Weaving）方式**    | **运行时织入**（基于代理对象拦截方法调用）                 | **编译期织入（CTW）<br>类加载期织入（LTW）<br>运行时织入**   |
| **代理方式**               | **JDK 动态代理（基于接口）<br>CGLIB 动态代理（基于子类）** | **直接修改字节码，无需代理对象**                             |
| **能否增强 `final` 方法**  | ❌ **不能**                                                 | ✅ **可以**                                                   |
| **能否增强 `static` 方法** | ❌ **不能**                                                 | ✅ **可以**                                                   |
| **能否增强私有方法**       | ❌ **不能**                                                 | ✅ **可以**                                                   |
| **能否增强构造函数**       | ❌ **不能**                                                 | ✅ **可以**                                                   |
| **增强目标**               | **仅限 Spring 容器管理的 Bean**                            | **适用于所有 Java 类，包括非 Spring Bean**                   |
| **性能**                   | **较低**（方法调用需代理层拦截）                           | **较高**（直接修改字节码，方法调用时已包含增强逻辑）         |
| **配置难度**               | **简单**（基于 Spring 配置）                               | **较复杂**（需 `aspectjweaver` 配置 CTW 或 LTW）             |
| **是否需要额外依赖**       | **无需额外依赖**（Spring 自带）                            | **需要 `aspectjweaver` 运行时或 `ajc` 编译器**               |
| **Spring 是否支持**        | ✅ **默认支持**                                             | ✅ **需额外配置 AspectJ 兼容模式**                            |
| **适用场景**               | **Spring 业务层 AOP（事务、日志、权限）**                  | **系统级 AOP（性能监控、代码审查、全局日志）**               |

------

 **如何选择？**

✅ **Spring AOP（运行时增强）**：

- 适用于 **Spring 管理的 Bean**
- 适合 **事务管理、日志记录、权限控制等业务层 AOP**
- **简单易用**，无需特殊编译器
- **缺点**：不能增强 `final` / `static` / `private` 方法，性能稍低

✅ **AspectJ AOP（编译时增强 & 类加载时增强）**：

- 适用于 **高性能 AOP、全局 AOP**
- 可增强 **`final` / `static` / `private` 方法 & 构造函数**
- **缺点**：配置较复杂，需要 `aspectjweaver` 或 `ajc` 编译

**总结**：
🔹 **如果是 Spring 项目，Spring AOP（运行时增强）足够满足大部分需求**。
🔹 **如果需要更强大的 AOP 能力（静态方法、构造函数、非 Spring Bean），AspectJ AOP 更合适**。
#### 5. FactoryBean 和 BeanFactory有什么区别？

BeanFactory 是 Bean 的工厂， ApplicationContext 的父类，IOC 容器的核心，负责生产和管理 Bean 对象。

FactoryBean 是 Bean，可以通过实现 FactoryBean 接口定制实例化 Bean 的逻辑，通过代理一个Bean对象，对方法前后做一些操作。

### 7.Spring是怎么解决循环依赖的？

#### **1. 什么是循环依赖？**

**循环依赖**：**两个或多个 Bean 之间相互依赖，导致 Spring 无法正常创建对象**。
示例：

```java
@Component
public class A {
    @Autowired
    private B b;
}

@Component
public class B {
    @Autowired
    private A a;
}
```

- **A 需要 B，B 也需要 A**，如果没有特殊处理，Spring 在创建 Bean 时会陷入死循环。

------

#### **2. Spring 解决循环依赖的核心：三级缓存**

Spring **默认使用三级缓存机制** 解决 **单例 Bean 的 Setter 依赖**。

| **缓存名称**                          | **存放内容**                | **作用**                   |
| ------------------------------------- | --------------------------- | -------------------------- |
| **一级缓存（singletonObjects）**      | **完全初始化好的单例 Bean** | 提供最终可用的 Bean        |
| **二级缓存（earlySingletonObjects）** | **提前曝光的 Bean 实例**    | 防止循环依赖时重复创建对象 |
| **三级缓存（singletonFactories）**    | **对象工厂，能够创建 Bean** | 允许 AOP 代理对象提前曝光  |

------

#### **3. Spring 三级缓存的工作流程**

**假设 A 依赖 B，B 依赖 A**，Spring 解决流程如下：

1️⃣ **创建 A（实例化，但未初始化）**

- A 还未赋值 `b`，Spring **先将 A 的创建工厂放入三级缓存**（`singletonFactories`）
- **此时 A 还不能使用**

2️⃣ **创建 B**

- B 依赖 A，Spring **在三级缓存找到 A 的工厂，并创建 A 的实例**
- A 的实例放入 **二级缓存（earlySingletonObjects）**，让 B 能够注入 A

3️⃣ **B 完成创建，并放入一级缓存**

- B 被完全创建，移动到 **一级缓存**（singletonObjects）

4️⃣ **A 继续创建**

- 由于 B 已经创建完成，A 也可以继续创建
- A 依赖的 B 直接从 **一级缓存** 取出
- A 完成创建，放入 **一级缓存**，循环依赖解决 ✅

------

#### **4. 为什么需要三级缓存？**

**只用二级缓存为什么不行？**

- **二级缓存只能存放实例对象，不能支持 AOP 代理对象提前曝光**
- **三级缓存可以存放 "对象工厂"**，AOP 代理对象可以在创建时暴露给依赖它的 Bean
- **Spring 在 AOP 代理时，会提前暴露代理对象到三级缓存**，保证循环依赖能正确解析

------

#### **5. 三级缓存示意图**

```
singletonObjects（一级缓存）:   存放完全初始化好的 A、B
earlySingletonObjects（二级缓存）：存放已实例化但未初始化的 A
singletonFactories（三级缓存）：存放 A 对象的工厂
```

------

#### **6. Spring 不能解决的循环依赖**

| **情况**                             | **Spring 默认支持？** | **原因**                                       |
| ------------------------------------ | --------------------- | ---------------------------------------------- |
| **Setter 依赖（`@Autowired` 注入）** | ✅ **支持**            | 三级缓存提前暴露对象                           |
| **构造器依赖**                       | ❌ **不支持**          | Bean 还未实例化，无法提前暴露                  |
| **Prototype 作用域 Bean**            | ❌ **不支持**          | **Prototype 不存缓存**，无法提前暴露           |
| **`FactoryBean` 之间的依赖**         | ❌ **不支持**          | `FactoryBean` 生成的对象逻辑复杂，不会提前暴露 |
| **`@DependsOn` 指定依赖顺序**        | ❌ **不支持**          | 强制指定顺序，可能导致循环依赖死锁             |

------

#### **7. 重点总结**

✅ **Spring 通过**`singletonFactories` **（三级缓存）提前暴露 Bean 解决 Setter 方式循环依赖**
❌ **构造器注入、Prototype 作用域、`FactoryBean` 依赖、`@DependsOn` 的循环依赖无法解决**
🔹 **三级缓存的作用：支持 AOP 代理对象提前曝光，避免二级缓存无法支持代理对象的问题**
### 8. 为什么要三级缓存？二级不行吗？

不可以，主要是为了生成代理对象。

 **重点总结**

✅ **三级缓存允许 AOP 代理对象提前暴露**，保证事务、切面等功能生效  
❌ **如果只用二级缓存，B 可能注入的是未代理的 A，导致事务、切面失效**  
💡 **核心点：三级缓存存放 Bean 工厂，确保 AOP 代理对象被正确注入**  

### 9.Spring事务传播机制有哪些？

1. **propagation_required**： 如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这也是通常我们的默认选择。
2. **propagation_requires_new**：创建新事务，无论当前存不存在事务，都创建新事务。
3. **propagation_nested：** 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。
4. **propagation_not_supported**：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
5. **propagation_never**：以非事务方式执行，如果当前存在事务，则抛出异常。
6. **propagation_mandatory**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
7. **propagation_supports**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。‘



### 10.Spring 事务在哪几种情况下会失效？为什么？
 **Spring 事务失效的常见情景总结**

| **失效情景**                                            | **失效原因**                                                 |                         **解决方案**                         |
| ------------------------------------------------------- | ------------------------------------------------------------ | :----------------------------------------------------------: |
| **1. 直接 `new` 出来的对象，事务不起作用**              | `new` 出来的对象不是 Spring 管理的 Bean，Spring 事务依赖 AOP 代理，而手动 `new` 出来的对象不会被代理。 |      通过 **Spring 容器** 获取 Bean，而不是手动 `new`。      |
| **2. MySQL MyISAM 引擎不支持事务**                      | MyISAM 引擎不支持事务，Spring 事务依赖数据库支持事务机制。   | 确保表使用 **InnoDB** 引擎，可以执行 `SHOW TABLE STATUS` 语句检查。 |
| **3. `@Transactional` 注解到非 `public` 方法上**        | Spring 事务基于 AOP 代理，而代理只会拦截 `public` 方法，非 `public` 方法不会被代理。 |     确保 `@Transactional` 注解应用于 **`public` 方法**。     |
| **4. 类内部方法调用，事务不起作用**                     | 方法在类内部调用时，相当于 `this.method()`，不会经过 AOP 代理，因此不会触发事务机制。 | 通过 **Spring 容器** 调用 `bean.method()`，或使用 `ApplicationContext.getBean()` 方式调用。 |
| **5. 抛出的异常类型不符合回滚条件**                     | Spring 默认只回滚 `RuntimeException` 及其子类，不回滚 `CheckedException`。 | 在 `@Transactional` 注解中显式指定 `rollbackFor = Exception.class`。 |
| **6. 异常被 `catch` 后未抛出，事务不回滚**              | Spring 事务回滚依赖于未被捕获的异常，如果异常被 `catch`，Spring 无法感知异常，事务不会回滚。 |      捕获异常后，必须 **重新抛出**，确保事务感知异常。       |
| **7. `Propagation.NOT_SUPPORTED` 传播行为导致事务失效** | `Propagation.NOT_SUPPORTED` 表示不以事务运行，即使调用了事务方法，也会挂起当前事务。 | 修改事务传播行为，例如 `Propagation.REQUIRED` 或 `Propagation.REQUIRES_NEW`。 |
| **8. 事务管理器类型不匹配**                             | 使用的 `DataSourceTransactionManager` 适用于 **JDBC**，但如果使用 **JPA**，则需要 `JpaTransactionManager`。 | 确保使用 **正确的事务管理器**，如 `@EnableTransactionManagement` 结合 `PlatformTransactionManager`。 |
| **9. 数据库操作不支持事务**                             | 执行 `DDL`（如 `CREATE TABLE`、`ALTER TABLE`）或某些 `批量更新` 操作时，事务不会生效。 |    避免在事务中执行 DDL 语句，确保所有操作都受事务管理。     |

#### **Spring 事务失效示例（4、5、6）**

 **4. 类内部方法调用，事务无效**

**错误示例（事务不会生效）**

```java
@Service
public class OrderService {
    @Transactional
    public void transactionalMethod() { 
        // 事务逻辑
    }

    public void outerMethod() {
        transactionalMethod(); // 直接调用，事务无效
    }
}
```

**正确示例（通过 Spring 代理调用事务方法）**

```java
@Service
public class OrderService {
    @Autowired
    private OrderService orderService;

    public void outerMethod() {
        orderService.transactionalMethod(); // 事务生效
    }

    @Transactional
    public void transactionalMethod() { 
        // 事务逻辑
    }
}
```

------

 **5. 抛出的异常类型不符合回滚条件**

**错误示例（CheckedException 不回滚）**

```java
@Service
public class OrderService {
    @Transactional
    public void someMethod() throws Exception {
        throw new Exception("Checked Exception"); // 事务不会回滚
    }
```

**正确示例（显式指定 `rollbackFor`）**

```java
@Service
public class OrderService {
    @Transactional(rollbackFor = Exception.class)
    public void someMethod() throws Exception {
        throw new Exception("Checked Exception"); // 事务回滚
    }
}
```

------

**6. 异常被 `catch` 后未抛出，事务不回滚**

**错误示例（异常被捕获，事务不会回滚）**

```java
@Service
public class OrderService {
    @Transactional
    public void someMethod() {
        try {
            // 业务逻辑
        } catch (Exception e) {
            System.out.println("异常被捕获，但未抛出"); 
        }
    }
}
```

**正确示例（异常需重新抛出）**

```java
@Service
public class OrderService {
    @Transactional
    public void someMethod() {
        try {
            // 业务逻辑
        } catch (Exception e) {
            throw new RuntimeException(e); // 事务回滚
        }
    }
}
```

------

 **总结**

- **类内部方法调用事务无效** → 需通过 **Spring 代理调用**（`@Autowired`）。
- **默认仅回滚 `RuntimeException`** → 需 **显式指定 `rollbackFor = Exception.class`**。
- **异常被 `catch` 后事务不回滚** → 需 **重新抛出 `RuntimeException`** 以触发事务回滚。






### 11.**SpringBoot的启动流程:**

 **Spring Boot 启动流程概览**

启动 Spring Boot 其实就是**创建并初始化 Spring 容器（ApplicationContext）**，具体步骤如下：

| **步骤**                        | **干了什么？**                                  | **关键类/方法**              |
| ------------------------------- | ----------------------------------------------- | ---------------------------- |
| **1. 启动 SpringApplication**   | 解析启动参数，确定应用类型（Web、非 Web）       | `SpringApplication`          |
| **2. 读取配置信息**             | 解析 `application.yml`、环境变量等              | `ConfigurableEnvironment`    |
| **3. 创建 Spring 容器**         | 根据应用类型创建合适的 `ApplicationContext`     | `createApplicationContext()` |
| **4. 加载 Bean 并进行依赖注入** | 通过扫描、自动配置等方式，实例化 Bean           | `refreshContext()`           |
| **5. 运行 Spring Boot 组件**    | 启动 Tomcat（Web 应用）、加载监听器等           | `onRefresh()`                |
| **6. 执行 Runner 组件**         | 运行 `CommandLineRunner` 和 `ApplicationRunner` | `callRunners()`              |

 **一句话概括**

Spring Boot 启动就是**创建 Spring 容器、扫描 Bean、自动注入、初始化 Web 服务器**的过程。整个流程由 `SpringApplication.run()` 方法控制，最终启动一个可用的 Spring Boot 应用。



**在刷新容器的时候会去解析启动类，而启动类的注解使用的是@SpringBootApplication。**

这是一个复合注解，里面包含了@ComponentScan，@EnableAutoConfiguration，@SpringBootConfiguration 这三个注解

* @EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置
* @Configuration：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境
* @ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下


### 12.**SpringBoot-starter的作用**
Spring Boot Starter 是 **Spring Boot 官方或社区提供的一组预配置依赖包**，可以**快速引入某个功能的相关组件**，避免繁琐的手动配置。

💡 **简单来说，Starter 就是一个“一键安装包”，帮你省去手动配置各种依赖的麻烦！**

Spring Boot 提供了许多官方 `Starter`，用于不同的场景：

| **Starter 依赖**                | **作用**                                                |
| ------------------------------- | ------------------------------------------------------- |
| `spring-boot-starter`           | **核心 Starter**，包含 Spring Boot 基础组件             |
| `spring-boot-starter-web`       | **开发 Web 应用**（包含 Tomcat + Spring MVC + Jackson） |
| `spring-boot-starter-data-jpa`  | **JPA 访问数据库**（包含 Hibernate）                    |
| `spring-boot-starter-jdbc`      | **JDBC 访问数据库**                                     |
| `spring-boot-starter-thymeleaf` | **集成 Thymeleaf 模板引擎**                             |
| `spring-boot-starter-security`  | **集成 Spring Security 进行认证和授权**                 |
| `spring-boot-starter-test`      | **集成 JUnit + Mockito + Spring Test 进行测试**         |
| `spring-boot-starter-cache`     | **提供缓存支持（如 Redis）**                            |
| `spring-boot-starter-amqp`      | **支持 RabbitMQ 消息队列**                              |
| `spring-boot-starter-actuator`  | **提供应用监控和管理**                                  |

 **总结**

- **Spring Boot Starter 是一组预配置的依赖集合**，用于简化 Spring 组件的集成。
- **通过 Starter，开发者可以快速引入某个功能**，避免繁琐的手动配置。
- **Spring Boot 内置多个官方 Starter**，涵盖 Web、数据库、消息队列等多个领域。
- **开发者还可以创建自定义 Starter**，以便在公司或团队内部复用公共组件。

💡 **一句话总结：**
👉 **Spring Boot Starter = "一键安装包" + "自动配置"**，让开发更简单、更高效！


### 13.[Spring SpringMVC SpringBoot 常用注解说明](https://blog.csdn.net/a964921988/article/details/88933707)

**@Component @Bean 区别:**

1、@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。

2、@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。

两者的目的是一样的，都是注册bean到Spring容器中。

区别：

@Component（@Controller、@Service、@Repository）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。而@Bean注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。

@Component 作用于类，@Bean作用于方法。

总结：

@Component和@Bean都是用来注册Bean并装配到Spring容器中，但是Bean比Component的自定义性更强。可以实现一些Component实现不了的自定义加载类。

### 14.[Spring中事务的使用、抽象机制及模拟Spring事务实现](https://blog.51cto.com/u_15050718/2624255)

### 15.[SpringBoot自定义注解的简单实现](https://www.jianshu.com/p/e1073a12c571)

### 16.Spring、Spring MVC、Spring Boot 的区别

Spring 生态系统包括 **Spring、Spring MVC 和 Spring Boot**，它们各自有不同的作用，下面用表格的方式来对比它们的核心区别：

------

 **1. 对比表格**

| **对比项**              | **Spring**                                                   | **Spring MVC**                                               | **Spring Boot**                                              |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **定义**                | **Spring 核心框架**，提供 IoC（依赖注入）和 AOP（面向切面编程）功能 | **Spring 的 Web 框架**，用于构建 Web 应用（MVC 模式）        | **Spring 快速开发框架**，简化 Spring 配置，提供自动化功能    |
| **主要作用**            | **管理 Bean**，实现依赖注入、事务管理、AOP、事件监听等       | **处理 Web 请求**，基于 Servlet 的 MVC 设计模式，支持 RESTful API | **简化 Spring 开发**，提供自动装配、内嵌 Web 服务器（如 Tomcat） |
| **是否依赖 Spring**     | **独立存在**，是 Spring 生态的基础                           | **依赖 Spring**，基于 Spring IoC 容器                        | **基于 Spring**，默认集成 Spring 和 Spring MVC               |
| **是否支持 Web**        | **不专门用于 Web**，但可以用作后台服务                       | **专门用于 Web 开发**，用于处理 HTTP 请求                    | **支持 Web 应用**，默认集成 Spring MVC                       |
| **是否需要手动配置**    | **需要 XML 或 Java 配置**                                    | **需要手动配置 DispatcherServlet、视图解析器等**             | **零配置或少量配置**，约定优于配置                           |
| **是否需要 Web 服务器** | **不需要**                                                   | **需要外部 Web 服务器（如 Tomcat）**                         | **内嵌 Web 服务器（Tomcat、Jetty）**，开箱即用               |
| **开发复杂度**          | **较复杂**，需要手动管理 Bean 和依赖                         | **较复杂**，需要手动配置 Web 组件                            | **简单高效**，Spring Boot Starter 直接引入依赖即可使用       |
| **典型使用场景**        | **适用于所有 Java 应用**，如后台服务、任务调度等             | **适用于 Web 开发**，如网站、API 接口                        | **适用于快速开发 Spring 应用**，微服务、REST API、后台管理系统等 |

 **2. 关系总结**

- **Spring 是基础**，它提供了 IoC（控制反转）和 AOP（面向切面编程），用于管理 Bean 和依赖注入。
- **Spring MVC 是基于 Spring 的 Web 框架**，专门用于处理 HTTP 请求，适用于 Web 开发。
- **Spring Boot 是 Spring 的简化版本**，它封装了 Spring 和 Spring MVC，提供了自动配置功能，让开发者可以**快速搭建 Spring 应用**。


 **3. 适用场景**

- **Spring**：适用于所有 Java 项目，不限于 Web 开发，比如企业级应用、定时任务、数据处理等。
- **Spring MVC**：适用于传统 Web 开发，如网站、管理后台、REST API 等。
- **Spring Boot**：适用于快速开发 Web 服务、微服务、云应用、分布式系统等。

 **4. 总结一句话**
- **Spring** 负责管理对象（Bean），提供 IoC、AOP。
- **Spring MVC** 负责处理 Web 请求，实现 MVC 设计模式。
- **Spring Boot** 负责简化 Spring 开发，提供自动配置、内嵌服务器，让开发更简单。

💡 **如果你要开发 Web 项目，直接用 Spring Boot，因为它默认集成了 Spring 和 Spring MVC，省去大量配置工作！** 🚀

## 五、Mybatis

**1、什么是mybatis？**

（1）mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。

（2）mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。

（3）MyBatis 支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJO映射成数据库中的记录。

 

**2、Mybait的优点：**

（1）简单易学，容易上手（相比于Hibernate） —- 基于SQL编程；

（2）JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；

（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDBC提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。

（4）提供了很多第三方插件（分页插件 / 逆向工程）；

（5）能够与Spring很好的集成；

（6）MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，解除sql与程序代码的耦合，便于统一管理和优化，并可重用。

（7）提供XML标签，支持编写动态SQL语句。

（8） 提供映射标签，支持对象与数据库的ORM字段关系映射。

（9）提供对象关系映射标签，支持对象关系组建维护。

 

**3、MyBatis框架的缺点：**

（1）SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。

（2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

 

**4、MyBatis框架适用场合：**

（1）MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。

（2）对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。

 

**5、MyBatis与Hibernate有哪些不同？**

（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 

（2）Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 

（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 

 

**6、#{}和${}的区别是什么？**

\#{}是预编译处理，${}是字符串替换。

Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；

Mybatis在处理${}时，就是把${}替换成变量的值。

使用#{}可以有效的防止SQL注入，提高系统安全性。

 

**7、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？**

第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。

   select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};

第2种： 通过来映射字段名和实体类属性名的一一对应的关系

select * from orders where order_id=#{id}

```xml
    <!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–>
    <result property = “orderno” column =”order_no”/>
    <result property=”price” column=”order_price” />
</reslutMap>
```

**8、 模糊查询like语句该怎么写?**

第1种：在Java代码中添加sql通配符。

```xml
string wildcardname = “%smi%”;
list<name> names = mapper.selectlike(wildcardname);

<select id=”selectlike”>
 select * from foo where bar like #{value}
</select>
```

第2种：在sql语句中拼接通配符，会引起sql注入

```xml
string wildcardname = “smi”;
list<name> names = mapper.selectlike(wildcardname);

<select id=”selectlike”>
     select * from foo where bar like "%"#{value}"%"
</select>
```

第3种：使用sql中的字符串拼接函数

```xml
<select id="searchStudents" resultType="com.example.entity.StudentEntity"
        parameterType="com.example.entity.StudentEntity">
        SELECT * FROM test_student
        <where>
            <if test="age != null and age != '' and compare != null and compare != ''">
                age
                ${compare}
                #{age}
            </if>
            <if test="name != null and name != ''">
                AND name LIKE CONCAT(CONCAT('%',#{name},'%'))
            </if>
            <if test="address != null and address != ''">
                AND address LIKE CONCAT(CONCAT('%',#{address},'%'))
            </if>
        </where>
        ORDER BY id
    </select>
```

**9、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？**

Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，
Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。
Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。

**10、Mybatis是如何进行分页的？分页插件的原理是什么？**
Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。

 **11、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？**
第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。
有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。

 

**12、如何执行批量插入?**

第1种：在java代码中反复调用

首先,创建一个简单的insert语句:

```xml
  <insert id=”insertname”>
       insert into names (name) values (#{value})
  </insert>
```

  然后在java代码中像下面这样执行批处理插入:

```java
list<string> names = new arraylist();
  names.add(“fred”);
  names.add(“barney”);
  names.add(“betty”);
  names.add(“wilma”);

  // 注意这里 executortype.batch
  sqlsession sqlsession = sqlsessionfactory.opensession(executortype.batch);
  try {
   namemapper mapper = sqlsession.getmapper(namemapper.class);
   for (string name : names) {
       mapper.insertname(name);
   }
   sqlsession.commit();
  }catch(Exception e){
   e.printStackTrace();
   sqlSession.rollback(); 
   throw e; 
    }
    finally {
       sqlsession.close();
  }
```

第2种：使用foreach进行批量插入

```xml
 <!-- 批量导入设备（从Excel表中导入设备列表） -->
   <insert id="batchAddDevice">
   	INSERT INTO hk_device ( mac_address,device_type_id,descript, device_group_id,
   	receive_num,is_delete,device_status,create_time,create_user,update_time ) VALUES
<!--//index表示在迭代过程中，每次迭代到的位置，-->
   	 <foreach collection="devices" item="device" index="index" separator=",">
          ( #{device.macAddress},#{device.deviceTypeId},#{device.descript},
   		 #{device.deviceGroupId},#{device.receiveNum},#{device.isDelete},#{device.devStatus},
   		 #{device.createTime},#{device.createUser},#{device.updateTime} ) 
       </foreach>
   </insert>
   <!-- foreach标签，进行遍历 -->
    <!-- collection：遍历的集合，这里是QueryVo的ids属性 -->
   	<!-- item：遍历的项目，可以随便写，，但是和后面的#{}里面要一致 -->
   	<!-- open：在前面添加的sql片段 -->
   	<!-- close：在结尾处添加的sql片段 -->
   	<!-- separator：指定遍历的元素之间使用的分隔符 -->
```



**13、如何获取自动生成的(主)键值?**

insert 方法总是返回一个int值 - 这个值代表的是插入的行数。

而自动生成的键值在 insert 方法执行完后可以被设置到传入的参数对象中。

useGeneratedKeys true，需要你表主键自动增长 keyProperty id，主键名称为id 

示例:

```xml
<insert id="insertname" usegeneratedkeys="true" keyproperty="id">
     insert into names (name) values (#{name})
</insert>
```



```java
name name = new name();
name.setname(“fred”);
int rows = mapper.insertname(name);
// 完成后,id已经被设置到对象中
system.out.println(“rows inserted = ” + rows);
system.out.println(“generated key value = ” + name.getid());
```

**14、在mapper中如何传递多个参数?**

（1）第一种：

```xml
 //DAO层的函数 Public UserselectUser(String name,String area);
//对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。
<select id="selectUser"resultMap="BaseResultMap">  
    select *  fromuser_user_t   whereuser_name = #{0} anduser_area=#{1}  
</select>  
```

（2）第2种： 使用 @param 注解:

```java
  import org.apache.ibatis.annotations.param;
      public interface usermapper {
       user selectuser(@param(“username”) string username,
       @param(“hashedpassword”) string hashedpassword);
      }
```

然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):

```xml
  <select id=”selectuser” resulttype=”user”>
       select id, username, hashedpassword
       from some_table
       where username = #{username}
       and hashedpassword = #{hashedpassword}
</select>
```

（3）第三种：多个参数封装成map

```java
try{try{
//映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL
//由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数
Map<String, Object> map = new HashMap();
map.put(“start”, start);
map.put(“end”, end);
return sqlSession.selectList(“StudentID.pagination”, map);
}catch(Exception e){
e.printStackTrace();
sqlSession.rollback();
throw e; }
finally{
MybatisUtil.closeSqlSession();
}
```

**15、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？**

Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。

Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。

其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。

**16、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？**

答：还有很多其他的标签，、、、、，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。

 **17、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？**

 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。

 原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。

 

**18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？**

Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。

 

**19、 一对一、一对多的关联查询 ？**

```xml
<mapper namespace="com.lcb.mapping.userMapper">  
    <!--association  一对一关联查询 -->  
    <select id="getClass" parameterType="int" resultMap="ClassesResultMap">  
        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#{id}  
    </select>  

    <resultMap type="com.lcb.user.Classes" id="ClassesResultMap">  
        <!-- 实体类的字段名和数据表的字段名映射 -->  
        <id property="id" column="c_id"/>  
        <result property="name" column="c_name"/>  
        <association property="teacher" javaType="com.lcb.user.Teacher">  
            <id property="id" column="t_id"/>  
            <result property="name" column="t_name"/>  
        </association>  
    </resultMap>  

 

    <!--collection  一对多关联查询 -->  
    <select id="getClass2" parameterType="int" resultMap="ClassesResultMap2">  
        select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#{id}  
    </select>  
     
    <resultMap type="com.lcb.user.Classes" id="ClassesResultMap2">  
        <id property="id" column="c_id"/>  
        <result property="name" column="c_name"/>  
        <association property="teacher" javaType="com.lcb.user.Teacher">  
            <id property="id" column="t_id"/>  
            <result property="name" column="t_name"/>  
        </association>  
     
        <collection property="student" ofType="com.lcb.user.Student">  
            <id property="id" column="s_id"/>  
            <result property="name" column="s_name"/>  
        </collection>  
    </resultMap>  
</mapper> 
```

**20、MyBatis实现一对一有几种方式?具体怎么操作的？**

​    有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成; 嵌套查询是先查一个表,根据这个表里面 的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。

**21、MyBatis实现一对多有几种方式,怎么操作的？**

​    有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配 置collection节点配置一对多的类就可以完成; 嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。

**22、简述Mybatis的插件运行原理，以及如何编写一个插件。**

答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

编写插件：实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

 

**23、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？**

答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。

当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。

 

 **24、Mybatis的一级、二级缓存:**

1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。

2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；

3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

**25、什么是MyBatis的接口绑定,有什么好处？**

​    接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置.

 **26、接口绑定有几种实现方式,分别是怎么实现的? **

​    接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名.

 

**27、什么情况下用注解绑定,什么情况下用xml绑定 ？**

当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。

**28、使用MyBatis的mapper接口调用时有哪些要求？**

① Mapper接口方法名和mapper.xml中定义的每个sql的id相同 
② Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 
③ Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 
④ Mapper.xml文件中的namespace即是mapper接口的类路径。

 

**29、Mapper编写有哪几种方式？**

第一种：接口实现类继承SqlSessionDaoSupport： 
使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件 
（1）在sqlMapConfig.xml中配置mapper.xml的位置

```xml
<mappers>
    <mapper resource="mapper.xml文件的地址" />
    <mapper resource="mapper.xml文件的地址" />
</mappers>
```

（2）定义mapper接口
（3）实现类集成SqlSessionDaoSupport
mapper方法中可以this.getSqlSession()进行数据增删改查。
（4）spring 配置

```xml
<bean id=" " class="mapper接口的实现">
    <property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
</bean>
```

第二种：使用org.mybatis.spring.mapper.MapperFactoryBean：
（1）在sqlMapConfig.xml中配置mapper.xml的位置
如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置

```xml
<mappers>
    <mapper resource="mapper.xml文件的地址" />
    <mapper resource="mapper.xml文件的地址" />
</mappers>
```

（2）定义mapper接口
注意
①mapper.xml中的namespace为mapper接口的地址
②mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致
③Spring中定义

```xml
<bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
    <property name="mapperInterface"   value="mapper接口地址" /> 
    <property name="sqlSessionFactory" ref="sqlSessionFactory" /> 
</bean>

```

第三种：使用mapper扫描器：
（1）mapper.xml文件编写：
注意：
mapper.xml中的namespace为mapper接口的地址
mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致
如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置
（2）定义mapper接口
注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录
（3）配置mapper扫描器

```xml
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="mapper接口包地址"></property>
    <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/> 
</bean>
```

（4）使用扫描器后从spring容器中获取mapper的实现对象

**30、Mybatis比IBatis比较大的几个改进是什么？**

（1）有接口绑定,包括注解绑定sql和xml绑定Sql ,

（2）动态sql由原来的节点配置变成OGNL表达式,

（3）在一对一,一对多的时候引进了association,在一对多的时候引入了collection 节点,不过都是在resultMap里面配置。

 

**31、IBatis和MyBatis在核心处理类分别叫什么？**

IBatis里面的核心处理类交SqlMapClient, MyBatis里面的核心处理类叫做SqlSession

 

**32、IBatis和MyBatis在细节上的不同有哪些？**

（1）在sql里面变量命名有原来的#变量# 变成了#{变量} 原来的$变量$变成了${变量},；

（2）原来在sql节点里面的class都换名字交type；

（3）原来的queryForObject、queryForList 变成了selectOne、selectList；

（4）原来的别名设置在映射文件里面放在了核心配置文件

#### Mybatis 和 Mybatis Plus 的区别

MyBatis和MyBatis-Plus对比表：

| **功能**          | **MyBatis**                              | **MyBatis-Plus**                                     |
| ----------------- | ---------------------------------------- | ---------------------------------------------------- |
| **CRUD 操作**     | 需要手动编写 SQL                         | 自动提供基本的 CRUD 操作，通过继承 `BaseMapper`      |
| **分页查询**      | 需要手动编写分页 SQL 或使用第三方插件    | 内置分页插件，简化分页查询操作                       |
| **代码生成**      | 不提供代码生成工具                       | 提供代码生成器，自动生成实体类、Mapper、XML          |
| **动态 SQL 构建** | 手动编写 SQL，使用 `if`、`choose` 等标签 | 使用 `Wrapper` 提供链式调用，简化 SQL 构建           |
| **性能分析**      | 需要额外的工具或手动分析                 | 提供性能分析插件，自动分析 SQL 执行时间              |
| **自动填充**      | 需要手动填充字段                         | 提供自动填充功能，通过 `MetaObjectHandler` 实现      |
| **事务管理**      | 通过外部框架（如 Spring）管理            | 通过外部框架（如 Spring）管理                        |
| **插件支持**      | 可以自定义插件                           | 自带多种插件，如分页插件、性能分析插件、乐观锁插件等 |

总体来说，**MyBatis-Plus** 是对 MyBatis 的增强，旨在提高开发效率，减少重复代码，尤其适用于日常的 CRUD 操作和分页查询。如果项目中大部分操作是常见的数据库操作，使用 MyBatis-Plus 可以大大简化代码量。而 MyBatis 则适用于对 SQL 控制要求非常高，或者需要更多定制化 SQL 的场景。
