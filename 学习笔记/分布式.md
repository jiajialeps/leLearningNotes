# 一、分布式事务

## **01 为什么需要分布式事务**

由于近十年互联网的发展非常迅速，很多网站的访问越来越大，集中式环境已经不能满足业务的需要了，只能按照业务为单位进行数据拆分(包含：垂直拆分与水平拆分)，以及按照业务为单位提供服务，从早期的集中式转变为面向服务架构的分布式应用环境。

举一个典型的例子，阿里的淘宝网站随着访问量越来越大，只能按照商品、订单、用户、店铺等业务为单位进行数据库拆分，以及按照业务为单位提供服务接口。

![img](https://pic2.zhimg.com/80/v2-886860e07964f3e7cecd0c439aec5789_720w.jpg)

这个时候 为了完成一个简单的业务功能，比如：购买商品后扣款，有可能需要横跨多个服务，涉及用户订单、商品库存、支付等多个数据库，而这些操作又需要在同一个事务中完，这就涉及到到了分布式事务。

本质上来说，分布式事务就是为了保证不同资源服务器的数据一致性。

## **02 分布式的一致性理论**

最早加州大学伯克利分校 Eric Brewer教授提出一个分布式系统特性的CAP理论。

**1.CAP 理论的不可能三角**

![img](https://pic3.zhimg.com/80/v2-e6b9d06542ea240216b7bcd51512b086_720w.jpg)

- 一致性（Consistency）
- 可用性（Availability）
- 分区容错性（Partition tolerance）

在分布式系统中，是不存在同时满足一致性 Consistency、可用性 Availability和分区容错性 Partition Tolerance三者的。

**一句话总结：一致性、可用性和分区容错在分布式事务中不可兼得。**

在绝大多数的场景，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。

这也是是后来发展出的BASE理论的基础。

**2.BASE 理论**

![img](https://pic2.zhimg.com/80/v2-127fb35f49eedcb5e8c4acd4dab4e319_720w.jpg)

- Basically Available（基本可用）
- Soft state（柔软状态）
- Eventually consistent（最终一致性）三个短语的简写。

BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。



https://mp.weixin.qq.com/s/7P2KbWjjX5YPZCInoox-xQ

## 03 分布式事务的解决方案**

**1.基于XA协议的两阶段提交 2PC(2-phase commit protocol)**

XA是一个分布式事务协议，XA中大致分为两部分：事务管理器和本地资源管理器,其中本地资源管理器往往由数据库实现，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。

![img](https://pic2.zhimg.com/80/v2-1caab0d161ae0af9a40bf5972a7e8f95_720w.jpg)



**大致的流程：**

- 第一阶段是表决阶段，所有参与者都将本事务能否成功的信息反馈发给协调者；
- 第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。

**优缺点**

尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，存在单点故障问题、性能问题、跨数据库问题。

**2.事务补偿TCC模式**

TCC方案其实是两阶段提交的一种改进，将整个业务逻辑的每个分支显式的分成了Try、Confirm、Cancel三个操作。

Try部分完成业务的准备工作，confirm部分完成业务的提交，cancel部分完成事务的回滚，基本原理如下图所示：

![img](https://pic1.zhimg.com/80/v2-ef8229600f354ace4104e736a7657a98_720w.jpg)

**优缺点**

对代码有侵入性，降低了锁冲突，提高了吞吐量，缺点是有时候并没有那么好实现。

**案例**

蚂蚁金服的DTS(prepare、commit、rollback)

**3.消息队列最终一致性方案**

干脆不用本地的消息表了，直接基于MQ来实现事务。比如阿里的RocketMQ就支持消息事务!


**流程**：

1.A系统先发送一个prepared消息到MQ，如果这个prepared消息发送失败,那么就直接取消操作,不执行了

2.如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉MQ发送确认消息，如果失败就告诉MQ回滚消息

3.如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地的事务

4.MQ会自动定时轮询所有prepared消息回调你的接口，问你这个消息是不是本地事务处理失败了，所有没发送确认的消息,是继续重试还是回滚？
这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，别确认消息发送失败了。

5.如果系统B的事务失败了咋办？
重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿



可靠消息最终一致性方案![img](http://img3.sycdn.imooc.com/5ef0104c00013f0a10310494.jpg)






总之，分布式系统中事务更多的是对CAP权衡，在实际应用中，根据业务要求、开发人员情况以及所用框架不同进行调整。

本文介绍了分布式事务的一些特性和解决方案，后续将持续输出成体系的分布式系统相关系列文章。

# 二、分布式锁

###  redis实现分布式锁




应用场景：互联网秒杀  抢购卷

模拟订单服务

##### 1.模拟搭建分布式服务

![](C:/Users/xule/Desktop/云端文档/04小课堂/medias/d03f5208a74ee2b6cedc94d884f1818.png)

##### 2.搭建nginx负载均衡

修改配置文件
1). 配置需要负载均衡的服务器
vi  nginx/conf/upstream.conf


```python
upstream LoadBalance{
        server 192.168.0.104:9083 weight=1 max_fails=2 fail_timeout=30s;
        server 192.168.0.104:9085 weight=1 max_fails=2 fail_timeout=30s;
}
```

2).配置反向代理
vi  nginx/conf/vhosts.conf

```python
 location /LoadBalance {
        proxy_set_header        X-Real-IP $remote_addr;
        proxy_set_header        Host $host;
        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass  http://LoadBalance/;
    }

```



代理后的ip：http://117.48.214.8/LoadBalance/iov/redis/test_syn



##### 3.setnx实现分布式锁

> Redis  API ： http://redisdoc.com

 SETNX key value

可用版本： >= 1.0.0

时间复杂度： O(1)

只在键 key 不存在的情况下， 将键 key 的值设置为 value 。

若键 key 已经存在， 则 SETNX 命令不做任何动作。

SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。



扩展

```shell
1、SET key value
含义：

         将字符串值 value 关联到 key 。

         如果 key 已经持有其他值， SET 就覆写旧值，无视类型。

2、SETEX key seconds value

含义：

          将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。

          如果 key 已经存在， SETEX 命令将覆写旧值。

返回值：

          设置成功时返回 OK 。

          当 seconds 参数不合法时，返回一个错误。

3、SETNX key value

含义：

          将 key 的值设为 value ，当且仅当 key 不存在。

          若给定的 key 已经存在，则 SETNX 不做任何动作。

          SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。

返回值：

          设置成功，返回 1 。

          设置失败，返回 0 。

4、GETSET key value

含义：

         将给定 key 的值设为 value ，并返回 key 的旧值(old value)。

         当 key 存在但不是字符串类型时，返回一个错误。

返回值：

          返回给定 key 的旧值。

          当 key 没有旧值时，也即是， key 不存在时，返回 null 。
```





返回值

命令在设置成功时返回 1 ， 设置失败时返回 0 。


代码一：

```java
@RequestMapping(value = "/testRedis")
	public String testRedis(){
	    String key = "stock";
	    Integer value = 500;
	    //获取锁
        
	    String clinetId=UUID.randomUUID().toString();
	    //插入缓存
	    redisTemplate.opsForValue().set(key, value.toString());
//	    //取缓存
	   try {
//		   Boolean result = redisTemplate.opsForValue().setIfAbsent("lockKey", "xule");
//		   redisTemplate.expire(key, 10,	TimeUnit.SECONDS);
		   Boolean result = redisTemplate.opsForValue().setIfAbsent(key, clinetId,10,TimeUnit.SECONDS);
		    if(!result) {
		    	return "error";
		    }
		    lock.lock();
		    	 int stock=Integer.parseInt(redisTemplate.opsForValue().get("stock"));
		 	    if(stock>0) {
		 	    	int realStock=stock-1;
		 	    	 redisTemplate.opsForValue().set(key, realStock+"");
		 	    	 System.out.println("85扣减成功，库存剩余："+realStock);
		 	    	
		 	    }else {
		 	    	 System.out.println("扣减失败，库存不足");
		 	    }
		   return  	"end";
		
	} finally {
	if(clinetId.equals(redisTemplate.opsForValue().get("key"))) {
		  redisTemplate.delete(key);
	}
	}
	    
	}
```



##### 4.redission实现分布式锁



实现原理	

 ![](C:/Users/xule/Desktop/云端文档/04小课堂/medias/61bedf404e509525ed54974babd1acd.png)



1）引入依赖：

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.5.4</version>
</dependency>

```

2）配置application.yml

```java
    redisson:
        address: redis://117.48.214.8:7379
         password:superman
 
```




代码实现：

```java
/**Redission实现分布式锁
	 * @return
	 */
	@RequestMapping(value = "/testRedission")
	public String testRedission(){
	    String key = "stock";
        RLock lock = redisson.getLock("k2");
	   try {
		   //执行具体逻辑...
		    lock.lock();
		    	 int stock=Integer.parseInt(redisTemplate.opsForValue().get("stock"));
		 	    if(stock>0) {
		 	    	int realStock=stock-1;
		 	    	 redisTemplate.opsForValue().set(key, realStock+"");
		 	    	 System.out.println("9001扣减成功，库存剩余："+realStock);
		 	    	
		 	    }else {
		 	    	 System.out.println("扣减失败，库存不足");
		 	    }
		   return  	"end";
		
	} finally {
		 lock.unlock();
	}
	    
	}
```

相关博客：https://www.cnblogs.com/chenkeyu/p/8514250.html

 

### Zookeeper实现分布式锁



##### 1.相关概念

- 有序节点：顾名思义就是有顺序的节点。zk会在生成节点时根据现有的节点数量添加整数序号。比如已经存在节点`/lock/node-0000000000`，下一个节点就是`/lock/node-0000000001`。
- 临时节点：临时节点只在zk会话期间存在，会话结束或超时时会被zk自动删除。
- 事件监听：通过zk的事件监听机制可以让客户端收到节点状态变化。主要的事件类型有节点数据变化、节点的删除和创建。

##### 2.实现步骤

了解完上面的三个概念，下面介绍具体实现。
 算法流程如下：
 1、每个客户端创建**临时有序**节点
 2、客户端获取节点列表，判断自己是否列表中的第一个节点，如果是就获得锁，如果不是就监听自己前面的节点，等待前面节点被删除。
 3、如果获取锁就进行正常的业务流程，执行完释放锁。
 上述步骤2中，有人可能担心如果节点发现自己不是序列最小的节点，准备添加监听器，但是这个时候前面节点正好被删除，这时候添加监听器是永远不起作用的，其实zk的API可以保证**读取和添加监听器是一个原子操作**。
 为什么要监听前一个节点而不是所有的节点呢？这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（**羊群效应**），而我们只希望它的后一个子节点收到通知。

Zookeeper 实现分布式锁的示意图如下：



![img](https:////upload-images.jianshu.io/upload_images/5611237-60ef4633a92e8870.png?imageMogr2/auto-orient/strip|imageView2/2/w/434/format/webp)

image.png

上图中左边是Zookeeper集群， lock是数据节点，node_1到node_n表示一系列的顺序临时节点，右侧client_1到client_n表示要获取锁的客户端。Service是互斥访问的服务。



 

使用zookeeper创建临时序列节点来实现分布式锁，适用于顺序执行的程序，大体思路就是创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……

##### 3.代码实现



1)引入依赖：

```xml
<dependency>
            <groupId>com.101tec</groupId>
            <artifactId>zkclient</artifactId>
            <version>0.10</version>
        </dependency>
```

2)代码案例：

```java
package com.cennavi.vehicle_networking_data.controller;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.KeeperException;
import org.apache.zookeeper.WatchedEvent;
import org.apache.zookeeper.Watcher;
import org.apache.zookeeper.Watcher.Event.KeeperState;
import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.ZooKeeper;
import org.apache.zookeeper.data.Stat;

public class ZooKeeperDistributedLock implements Watcher{
	
    private ZooKeeper zk;
    private String locksRoot= "/locks";
    private String productId;
    private String waitNode;
    private String lockNode;
    private CountDownLatch latch;
    private CountDownLatch connectedLatch = new CountDownLatch(1);
private int sessionTimeout = 30000; 

    public ZooKeeperDistributedLock(String productId){
        this.productId = productId;
         try {
	   String address = "192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181";
            zk = new ZooKeeper(address, sessionTimeout, this);
            connectedLatch.await();
        } catch (IOException e) {
            throw new LockException(e);
        } catch (InterruptedException e) {
            throw new LockException(e);
        }
    }
	@Override
    public void process(WatchedEvent event) {
        if(event.getState()==KeeperState.SyncConnected){
            connectedLatch.countDown();
            return;
        }

        if(this.latch != null) {  
            this.latch.countDown(); 
        }
    }

    public void acquireDistributedLock() {   
        try {
            if(this.tryLock()){
                return;
            }
            else{
                waitForLock(waitNode, sessionTimeout);
            }
        } catch (KeeperException e) {
            throw new LockException(e);
        } catch (InterruptedException e) {
            throw new LockException(e);
        } 
}

    public boolean tryLock() {
        try {
 		// 传入进去的locksRoot + “/” + productId
		// 假设productId代表了一个商品id，比如说1
		// locksRoot = locks
		// /locks/10000000000，/locks/10000000001，/locks/10000000002
            lockNode = zk.create(locksRoot + "/" + productId, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
   
            // 看看刚创建的节点是不是最小的节点
	 	// locks：10000000000，10000000001，10000000002
            List<String> locks = zk.getChildren(locksRoot, false);
            Collections.sort(locks);
	
            if(lockNode.equals(locksRoot+"/"+ locks.get(0))){
                //如果是最小的节点,则表示取得锁
                return true;
            }
	
            //如果不是最小的节点，找到比自己小1的节点
	  int previousLockIndex = -1;
            for(int i = 0; i < locks.size(); i++) {
		if(lockNode.equals(locksRoot + "/" + locks.get(i))) {
	         	    previousLockIndex = i - 1;
		    break;
		}
	   }
	   
	   this.waitNode = locks.get(previousLockIndex);
        } catch (KeeperException e) {
            throw new LockException(e);
        } catch (InterruptedException e) {
            throw new LockException(e);
        }
        return false;
    }
     
    private boolean waitForLock(String waitNode, long waitTime) throws InterruptedException, KeeperException {
        Stat stat = zk.exists(locksRoot + "/" + waitNode, true);
        if(stat != null){
            this.latch = new CountDownLatch(1);
            this.latch.await(waitTime, TimeUnit.MILLISECONDS);            	   this.latch = null;
        }
        return true;
}

    public void unlock() {
        try {
		// 删除/locks/10000000000节点
		// 删除/locks/10000000001节点
            System.out.println("unlock " + lockNode);
            zk.delete(lockNode,-1);
            lockNode = null;
            zk.close();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
}

    public class LockException extends RuntimeException {
        private static final long serialVersionUID = 1L;
        public LockException(String e){
            super(e);
        }
        public LockException(Exception e){
            super(e);
        }
}

	 

// 如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁，后面的每个人都会去监听排在自己前面的那个人创建的node上，一旦某个人释放了锁，排在自己后面的人就会被zookeeper给通知，一旦被通知了之后，就ok了，自己就获取到了锁，就可以执行代码了

}  


```

相关博客：https://www.jianshu.com/p/91976b27a188

# 三、分布式session 

##  cookie 	

在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。

##  session 

session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。

 

**集群部署时的分布式session如何实现？**

####  前言



> 由于Http连接是无状态的，所以使用Tomcat做服务器的时候Tomcat内部会维护一个叫做Session的东东用来保存客户端的状态，一般情况下每个客户端都有一个cookie里面保存着叫jsessionid的cookie，每次访问tomcat的时候都会携带上，Tomcat可以根据这个jsessionid找到对应的session。就像你去超市买东西，门口的储物柜可以视作一个session容器，而打出的二维码条就是cookie。
> 在分布式系统中，对于同一个客户端，访问哪个Tomcat服务器就会在哪个Tomcat里面创建session。简单来说我做一个登录功能，即第一次访问Tomcat的时候需要输入用户名密码，访问成功后就在自己的sesison里面写入用户名，那么我下次访问的时候直接检测session里是否有自己的用户名来判断自己是否处于登录状态了。现在问题来了，如果我第一次访问的是TomcatA，登录成功后由于nginx的负载均衡第二次访问打到了TomcatB上，那么TomcatB里面并没有我的用户名信息，所以我还需要重新登录。一个最直观的想法就是把TomcatA和TomcatB的session抽出来放到某一个位置，这样不管访问TomcatA还是TomcatB都会从同一个Session里面获取用户信息。
> SpringBoot以一个非常简洁易用的方式帮我们实现了分布式Session，我们需要做的仅仅是1个注解，几行配置，几行代码。

负载 ：  http://114.67.207.193/LoadBalance/GIS/getPort

http://114.67.200.2:8081/GIS/set?name=%22xule2%22

http://114.67.200.2:8081/GIS/get

####  示意图 

​	



 ![](C:/Users/xule/Desktop/云端文档/04小课堂/media/01_Distributed_session.png)

 



- 使用cookie来完成（很明显这种不安全的操作并不可靠）
- 使用Nginx中的ip绑定策略，同一个ip只能在指定的同一个机器访问（不支持负载均衡）
- 利用数据库同步session（效率不高）
- 使用tomcat内置的session同步 
- 使用token代替session
- **我们使用spring-session以及集成好的解决方案，存放在Redis中**



其实方法很多，但是常见常用的是三种：

 #### 实现方式



##### 1.tomcat + redis



> 这个其实还挺方便的，就是使用session的代码跟以前一样，还是基于tomcat原生的session支持即可，然后就是用一个叫做Tomcat RedisSessionManager的东西，让所有我们部署的tomcat都将session数据存储到redis即可。

 

在tomcat的配置文件中，配置一下

```xml
<Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" />

<Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager"
         host="{redis.host}"
         port="{redis.port}"
         database="{redis.dbnum}"
         maxInactiveInterval="60"/>


```



搞一个类似上面的配置即可，你看是不是就是用了RedisSessionManager，然后指定了redis的host和 port就ok了。

 ```xml
<Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" />
<Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager"
	 sentinelMaster="mymaster"
	 sentinels="<sentinel1-ip>:26379,<sentinel2-ip>:26379,<sentinel3-ip>:26379"
	 maxInactiveInterval="60"/>


 ```



 

> 还可以用上面这种方式基于redis哨兵支持的redis高可用集群来保存session数据，都是ok的

 

##### 2.spring session + redis

 

> 分布式会话的这个东西重耦合在tomcat中，如果我要将web容器迁移成jetty，难道你重新把jetty都配置一遍吗？

 

> 因为上面那种tomcat + redis的方式好用，但是会严重依赖于web容器，不好将代码移植到其他web容器上去，尤其是你要是换了技术栈咋整？比如换成了spring cloud或者是spring boot之类的。还得好好思忖思忖。

 

>  所以现在比较好的还是基于java一站式解决方案，spring了。人家spring基本上包掉了大部分的我们需要使用的框架了，spirng cloud做微服务了，spring boot做脚手架了，所以用sping session是一个很好的选择。

 

**pom.xml**

 ```xml
<dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session-data-redis</artifactId>
  <version>1.2.1.RELEASE</version>
</dependency>
<dependency>
  <groupId>redis.clients</groupId>
  <artifactId>jedis</artifactId>
  <version>2.8.1</version>
</dependency>

 ```

 

 

**spring配置文件中**

```xml
<bean id="redisHttpSessionConfiguration"
     class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration">
    <property name="maxInactiveIntervalInSeconds" value="600"/>
</bean>

<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">
    <property name="maxTotal" value="100" />
    <property name="maxIdle" value="10" />
</bean>

<bean id="jedisConnectionFactory"
      class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" destroy-method="destroy">
    <property name="hostName" value="${redis_hostname}"/>
    <property name="port" value="${redis_port}"/>
    <property name="password" value="${redis_pwd}" />
    <property name="timeout" value="3000"/>
    <property name="usePool" value="true"/>
    <property name="poolConfig" ref="jedisPoolConfig"/>
</bean>

```

 

**web.xml**

```xml
<filter>
    <filter-name>springSessionRepositoryFilter</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSessionRepositoryFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

```

  

**示例代码**

```java
@Controller
@RequestMapping("/test")
public class TestController {

@RequestMapping("/putIntoSession")
@ResponseBody
    public String putIntoSession(HttpServletRequest request, String username){
        request.getSession().setAttribute("name",  “leo”);

        return "ok";
    }

@RequestMapping("/getFromSession")
@ResponseBody
    public String getFromSession(HttpServletRequest request, Model model){
        String name = request.getSession().getAttribute("name");
        return name;
    }
}

```



 

> 上面的代码就是ok的，给sping session配置基于redis来存储session数据，然后配置了一个spring session的过滤器，这样的话，session相关操作都会交给spring session来管了。接着在代码中，就用原生的session操作，就是直接基于spring sesion从redis中获取数据了。

 

实现分布式的会话，有很多种很多种方式，我说的只不过比较常见的两种方式，tomcat + redis早期比较常用；近些年，解耦 tomcat，通过spring session来实现。

##### 3.SpringBoot利用Redis管理分布式Session



**配置maven**



```xml
<dependencies>
    <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
</dependencies>
```

**配置application.yml**

```yaml
spring:
  session:
    store-type: redis
    timeout: 3600s
    redis:
      flush-mode: on_save
      namespace: spring:session
  redis:
    host: 192.168.99.100
    port: 6379
    timeout: 5000ms

```



**代码示例**

```java
 	 	//主类首先开启EnableRedisHttpSession注解
@SpringBootApplication
@EnableRedisHttpSession
public class DistributeSessionApplication {

    public static void main(String[] args) {
        SpringApplication.run(DistributeSessionApplication.class, args);
    }
}

```



```java
//编写controller，set用于向session添加属性，get用于从session获取属性
package com.example.distributesession.controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

/**
 * @Author: 小混蛋
 * @CreateDate: 2018/12/11 17:20
 */
@RestController
public class TestController {

    @GetMapping("/set")
    public void test(HttpServletRequest request){
        request.getSession().setAttribute("message",request.getQueryString());
    }
    @GetMapping("/get")
    public Map<String,Object> two(HttpServletRequest request){
        Map<String,Object> map = new HashMap<>();
        map.put("sessionId",request.getSession().getId());
        map.put("message",request.getSession().getAttribute("message"));
        return map;
    }
}
```



测试：

> http://localhost:8081/GIS/set?name=%22xule2%22

> http://localhost:8082/GIS/get



##### 4. Spring Session Redis的原理简析

看了上面的配置，我们知道开启Redis Session的“秘密”在@EnableRedisHttpSession这个注解上。打开@EnableRedisHttpSession的源码：



```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(RedisHttpSessionConfiguration.class)
@Configuration
public @interface EnableRedisHttpSession {
    //Session默认过期时间,秒为单位，默认30分钟
	int maxInactiveIntervalInSeconds() default MapSession.DEFAULT_MAX_INACTIVE_INTERVAL_SECONDS;
    //配置key的namespace，默认的是spring:session，如果不同的应用共用一个redis，应该为应用配置不同的namespace，这样才能区分这个Session是来自哪个应用的
	String redisNamespace() default RedisOperationsSessionRepository.DEFAULT_NAMESPACE;
    //配置刷新Redis中Session的方式，默认是ON_SAVE模式，只有当Response提交后才会将Session提交到Redis
    //这个模式也可以配置成IMMEDIATE模式，这样的话所有对Session的更改会立即更新到Redis
	RedisFlushMode redisFlushMode() default RedisFlushMode.ON_SAVE;
    //清理过期Session的定时任务默认一分钟一次。
	String cleanupCron() default RedisHttpSessionConfiguration.DEFAULT_CLEANUP_CRON;
}
```



> 分布式session介绍：https://www.cnblogs.com/54chensongxia/p/12096493.html





## 四、分布式缓存